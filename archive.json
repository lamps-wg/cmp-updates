{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-02-20T01:26:40.266870+00:00",
  "repo": "lamps-wg/cmp-updates",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOInbtzM5ZzEGp",
      "title": "Ephemeral KEM key pair for message protection",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/2",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Antonio pointed me again at https://eprint.iacr.org/2017/634.pdf. \r\nIn figure 3 an authenticated key exchange protocol is described where both parties are authenticated. There P1 generates an ephemeral KEM key pair pk/sk and sends it together with of the encrypted value using P2's public KEM key to P2. In return P2 sends two encrypted values, one using the ephemeral public key pk and one using the public KEM key of P1. Finally all concatenate the three resulting keys using a hash function.\r\nShould we extend Section 5.1.3.4 accordingly also adding an ephemeral KEM key?",
      "createdAt": "2022-12-21T16:09:59Z",
      "updatedAt": "2023-06-15T15:48:44Z",
      "closedAt": "2023-06-15T15:48:44Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does anyone has an opinion?",
          "createdAt": "2023-01-19T08:29:59Z",
          "updatedAt": "2023-01-19T08:29:59Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Design team meeting minutes:\r\nWe submit the version of Section 5.1.3.4 with out the third HPKE and then ask on the LAMPS list if people think that we should add a third HPKE with an ephemeral KEM keypair to the exchange as proposed in figure 3 of the paper.",
          "createdAt": "2023-01-19T17:16:11Z",
          "updatedAt": "2023-01-19T17:23:31Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Design team meeting minutes:\r\nMike offered to read the paper and provide his opinion on this topic. ",
          "createdAt": "2023-01-19T17:16:47Z",
          "updatedAt": "2023-01-19T17:23:23Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some things I note from the paper:\r\n\r\n> In key exchange constructions using a KEM, it is common\r\nto hash the \u201cview\u201d of each participant (i.e., all received and\r\nsent messages) into the final key\r\n\r\nShould we do that? That would be equivalent to the TLS \"transcript\". It might solve one of the problems we have with the client and server using different values for `HPKE.L`.",
          "createdAt": "2023-01-19T23:15:41Z",
          "updatedAt": "2023-01-19T23:15:41Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is the relevant sentence for the issue of adding a 3rd (ephemeral) KEM key to the handshake:\r\n\r\n> Concretely, security of Kyber.AKE in the Canetti\u2013\r\nKrawczyk model with weak forward secrecy [27] follows\r\nMy u\r\ndirectly from the generic security bounds of [22], [37]. (Note\r\nthat full forward secrecy is not achievable for a two-round\r\nauthenticated key-exchange protocol [27].)\r\n\r\n---\r\nI agree with that analysis. Here is my reasoning:\r\n\r\nConsider first a basic 2-key KEM AKE \r\n\r\n```\r\nStatic long-term KEM keys: (pk_c, priv_c), (pk_s, priv_s)\r\n\r\nClient:\r\n(c1, k1) <- KEM.encaps(pk_s)\r\n\r\nServer:\r\nk1 <- KEM.decaps(c1, priv_s)\r\n(c2, k2) <- KEM.encaps(pk_c)\r\n\r\nClient: \r\nk2 <- KEM.decaps(c2, priv_c)\r\n\r\nBoth:\r\nkey := H(k1, k2)\r\n```\r\n\r\nHere if an attacker records the traffic `c1, c2` and then is able to learn, even some time later, both parties' private keys `priv_s, priv_c`, then they can re-run the KEM.decaps()'s and recover both `k1, k2`, and then the final `key`.\r\n\r\nThis is, I believe, already an improvement over the current CMP KeyTrans or KeyAgree message protection where only the server's private key is required to decrypt the exchanged key.\r\n\r\nThe paper goes a step further by adding an ephemeral key (I believe it should be fine to add it to either party). This means that obtaining `key` requires knowledge of both long-term private keys, plus the ephemeral private key which is discarded at the end of the handshake. They claim this provides \"weak forward secrecy\". I think they are implying that \"full forward secrecy\" would require both parties to have ephemeral keys, which would require an extra 0.5 round-trip to exchange the 4th ciphertext.\r\n\r\n--- \r\nMy opinion is that Static-Static KEM AKE is already improved over KeyTrans or KeyAgree in CMP, but if it does not cost us anything to add an ephemeral key as described in the paper, then why not.\r\n\r\nI would feel more confident if everyone thinks about this and agrees with my logic ... including Hans Aschaur, who has an excellent mind for these crypto puzzles.\r\n",
          "createdAt": "2023-01-19T23:39:33Z",
          "updatedAt": "2023-01-19T23:41:22Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The paper goes a step further by adding an ephemeral key (I believe it should be fine to add it to either party). This means that obtaining `key` requires knowledge of both long-term private keys, plus the ephemeral private key which is discarded at the end of the handshake. They claim this provides \"weak forward secrecy\". I think they are implying that \"full forward secrecy\" would require both parties to have ephemeral keys, which would require an extra 0.5 round-trip to exchange the 4th ciphertext.\r\n\r\nI am uncertain if an extra 0.5 round-trip would be required as the client could include its ephemeral public KEM key in the first genm messages together with its certificate. The first message exchange is unprotected, but I think a man-in-the-middle could exchange the ephemeral key, but this would also brake the establishment of the shared key later on.\r\n \r\n> My opinion is that Static-Static KEM AKE is already improved over KeyTrans or KeyAgree in CMP, but if it does not cost us anything to add an ephemeral key as described in the paper, then why not.\r\n\r\nAs of now [authkem ](https://github.com/claucece/draft-celi-wiggers-tls-authkem)dose not include a third ephemeral KEM key as well. But I see your point.\r\nWhat doe the implementer think about this? Is it cumbersome to add a third HPKE with an ephemeral KEM key to the exchange?",
          "createdAt": "2023-01-26T16:43:14Z",
          "updatedAt": "2023-01-26T16:43:14Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Some things I note from the paper:\r\n> \r\n> > In key exchange constructions using a KEM, it is common\r\n> > to hash the \u201cview\u201d of each participant (i.e., all received and\r\n> > sent messages) into the final key\r\n> \r\n> Should we do that? That would be equivalent to the TLS \"transcript\". It might solve one of the problems we have with the client and server using different values for `HPKE.L`.\r\n\r\nWhat do the implementers think, would it be much harder to incorporate a hash on the PKIMessage into the HPKE Send/RecieveExportBase than only incorporating transactionID, senderNonce, and recipNonce? ",
          "createdAt": "2023-01-26T16:48:08Z",
          "updatedAt": "2023-01-26T16:48:08Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will add L to HpkeCiphertext. Therefore I thing it is sufficient using transactionID, senderNonce, and recipNonce for domain separation.\r\n",
          "createdAt": "2023-02-28T08:15:02Z",
          "updatedAt": "2023-02-28T08:15:02Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I propose to go ahead without an additional ephemeral KEM key. This is also in line with draft-ietf-lamps-cms-kemri.",
          "createdAt": "2023-02-28T08:16:24Z",
          "updatedAt": "2023-02-28T08:16:24Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is also in line with draft-ietf-lamps-cms-kemri.\r\n\r\nI think their design rationale does not translate to CMP, so this justification is not sufficient. CMS is an offline / non-interactive protocol so they do not have the luxury of doing an online key establishment. CMP is already an online / interactive protocol, so we could add an ephemeral KEM without impacting the message flows.\r\n\r\nThat said, there is an argument that the KEMs in CMP are used for authentication, not for long-term confidentiality (except for encryption of server-generated keys?)\r\n\r\n\r\nI suggest we add a Security Consideration like the following:\r\n\r\n> Security Considerations\r\n> Forward Secrecy of KEMs\r\n> In general, mutually-authenticated KEM exchanges (\"Authenticated Key Exchanges (AKEs)\") embed an ephemeral KEM in order to add forward secrecy protecting against later decryption of the content if the long-term private keys become known. This attack does not apply because CMP uses mutually-authenticated KEM exchanges for the purposes of computing a MAC for authentication, so this usage does not have forward secrecy concerns.\r\n\r\n\r\nNOTE: this SecCon should mention the option for the client to provide an ephemeral protocol protection key if it wishes to have  forward secrecy on the encrypted server-generated key.",
          "createdAt": "2023-03-02T16:45:05Z",
          "updatedAt": "2023-03-02T16:51:13Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I feel like the forward secrecy is relevant for all keys used for CMP protection of central key generation. Therefore, I propose to extend the scope of this security consideration to protection of centrally generated keys. ",
          "createdAt": "2023-03-03T09:05:24Z",
          "updatedAt": "2023-03-03T09:05:24Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ounsworth What do you think of this text?\r\n`Forward Secrecy for long-term protection\r\n\r\nAuthenticity of CMP messages relies on signature-based or MAC-based protection. Long-term protection is not required as it is assumed that a PKI management operation using CMP is concluded in a reasonably short time.\r\n\r\nWhen encrypted values are transported as described in Section 5.2.2, long-term security requirements may be relevant.  CMP used CMS EnvelopedData for protecting such encrypted values.  As CMS is an offline / non-interactive protocol, it does not offer forward secrecy out of the box.  As CMP is an interactive protocol, ephemeral keys could be introduced instead of using the existing long-term keys.  This would introduce forward secrecy and would offer enhanced long-term security.`",
          "createdAt": "2023-03-03T09:22:10Z",
          "updatedAt": "2023-03-03T09:22:43Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the meantime the current draft contains the domain separation using the KemOtherInfo \r\n`  KemOtherInfo ::= SEQUENCE {\r\n    staticString     PKIFreeText,\r\n    transactionID    OCTET STRING,\r\n    senderNonce      OCTET STRING,\r\n    recipNonce       OCTET STRING,\r\n    len              INTEGER (1..MAX),\r\n    ct               OCTET STRING\r\n  }\r\n\r\nstaticString MUST be \"CMP-KEM\"\r\n\r\ntransactionID, senderNonce, and recipNonce MUST be the values from the message previously received containing the ciphertext ct in KemCiphertext\r\n\r\nlen MUST be the value from that KemCiphertext\r\n\r\nct MUST be the ciphertext from that KemCiphertext`\r\n\r\nDo we need all these data as context information for domain separation, specifically ct?",
          "createdAt": "2023-05-09T13:36:07Z",
          "updatedAt": "2023-05-09T13:39:22Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The second point in this issue was on adding perfect forward secresy using additional ephemeral KEM keys to the exchange.\r\nThe result of the current discussion is, not do do this, but to add the following ecurity consideration.\r\n`Forward Secrecy for long-term protection\r\n\r\nAuthenticity of CMP messages relies on signature-based or MAC-based protection. Long-term protection is not required as it is assumed that a PKI management operation using CMP is concluded in a reasonably short time.\r\n\r\nWhen encrypted values are transported as described in Section 5.2.2, long-term security requirements may be relevant. CMP used CMS EnvelopedData for protecting such encrypted values. As CMS is an offline / non-interactive protocol, it does not offer forward secrecy out of the box. As CMP is an interactive protocol, ephemeral keys could be introduced instead of using the existing long-term keys. This would introduce forward secrecy and would offer enhanced long-term security.`\r\n\r\nAny comments on the tect of this securtiy consideration?",
          "createdAt": "2023-05-09T13:38:55Z",
          "updatedAt": "2023-05-09T13:38:55Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we whish to add ephemeral keys, this would require the delivery of this ephemeral kem key together with the KEM certificate. This would require an additional id-it InfoTypeAndValue.\r\n\r\nThis should be optional, as it is only needed with encrypted delivery of a centrally generated key pair.\r\nDo we want to go this extra mile? ",
          "createdAt": "2023-05-09T13:45:48Z",
          "updatedAt": "2023-05-09T13:50:58Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we need to add the hash of the whole PKIMessage containing the KemCiphertext as input for KemOtherInfo?",
          "createdAt": "2023-05-10T14:49:25Z",
          "updatedAt": "2023-05-10T14:49:25Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 11.05.23\r\nProposal is to add TLS for the cases where longterm privacy is needed.",
          "createdAt": "2023-05-11T15:31:17Z",
          "updatedAt": "2023-05-11T15:31:17Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Meeting 11.05.23 Proposal is to add TLS for the cases where longterm privacy is needed.\r\n\r\nTo be clear: that is principally cases where private keys are transported over CMP.",
          "createdAt": "2023-05-11T15:37:39Z",
          "updatedAt": "2023-05-11T15:37:39Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ounsworth What do you think of this security consideration?\r\n@DDvO Any proposals for rephrasing?\r\n\r\n## Perfect Forward Secrecy\r\n\r\nLong-term security typically requires perfect forward secrecy (pfs).  PKI management operations are usially completed in a limited time and therefore CMP message protection providing integrity and authenticity does not require long-term security.  When encrypted valuest, e.g., centrally generated private keys or revocation passphrases, are transferred, long-term confidentiality and therefore pfs may be important.  In contrast, long-term security is may not be required when the indirect method is used to provide a POP {{sect-5.2.8.2}} by delivering the newly issued certificates in encrypted form.\r\n\r\nEncrypted values {{sect-5.2.2}} are transferred using CMS EnvelopedData [RFC5652] which does not offer pfs.  If long-term security is required, CMP messages SHOULD be transferred using TLS, or a comparable security protocol offering pfs.",
          "createdAt": "2023-05-24T15:51:33Z",
          "updatedAt": "2023-05-24T15:51:33Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Fixing some typos etc., re-ordering the items for streamlined reading, and taking into consideration that for the time frame of authenticity and integrity, not a whole CMP transaction is relevant but just a single message transfer:\r\n\r\n\r\nLong-term security typically requires perfect forward secrecy (pfs).\r\nWhen transferring encrypted long-term confidential values such as centrally generated private keys or revocation passphrases, pfs likely is important. \r\nYet it is not needed for CMP message protection providing integrity and authenticity because transfer of PKI management messages is usually completed in very limited time. \r\nFor the same reason it typically is not required for the indirect method of providing a POP {{sect-5.2.8.2}} delivering the newly issued certificate in encrypted form.\r\n\r\nEncrypted values {{sect-5.2.2}} are transferred using CMS EnvelopedData [RFC5652], which does not offer pfs. In cases where long-term security is needed, CMP messages SHOULD be transferred over a mechanism that provides pfs, such as TLS.\r\n",
          "createdAt": "2023-05-25T07:50:14Z",
          "updatedAt": "2023-05-25T07:50:14Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for rephrasing.",
          "createdAt": "2023-05-25T08:10:06Z",
          "updatedAt": "2023-05-26T10:48:12Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the updated text.   Looks good.   Just one comment:  Is there something that will indicate this part is in the context of KEM?   When I read it, I was thinking you can get PFS with an ephemeral ECDH (or DH) key in EnvelopedData.   So we probably need to make sure it is clear this applies when KEM is used because we don't offer PFS when KEM is used.",
          "createdAt": "2023-06-07T18:23:34Z",
          "updatedAt": "2023-06-07T18:23:34Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good.\r\n\r\nOne comment:\r\n> When transferring encrypted long-term confidential values such as centrally generated private keys or revocation passphrases, pfs likely is important.\r\n\r\nThere is actually more to this story. There is a chicken-and-egg situation here because you are typically encrypting the private keys or revocation keys back to the key holder, so if you have compromised the client sufficiently to obtain the (transport) keys then presumably you already have access to the keys being transported. This further reduces the importance of forward secrecy.",
          "createdAt": "2023-06-07T18:24:56Z",
          "updatedAt": "2023-06-07T18:27:21Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is there something that will indicate this part is in the context of KEM? When I read it, I was thinking you can get PFS with an ephemeral ECDH (or DH) key in EnvelopedData.\r\n\r\nCMS KeyAgreeRecipientInfo for EnvelopedData uses the static ECDH (or DH) public key from the recipient's certificate identified by the KeyAgreeRecipientIdentifier.\r\nSee https://datatracker.ietf.org/doc/html/rfc5652#section-6.2.2\r\n`The\r\n      KeyAgreeRecipientIdentifier is a CHOICE with two alternatives\r\n      specifying the recipient's certificate, and thereby the\r\n      recipient's public key, that was used by the sender to generate a\r\n      pairwise key-encryption key.`\r\nTherefore, I thought that psf is a general topic. \r\n@johngray-dev Am I wrong?",
          "createdAt": "2023-06-13T14:49:31Z",
          "updatedAt": "2023-06-13T14:57:53Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There is actually more to this story. There is a chicken-and-egg situation here because you are typically encrypting the private keys or revocation keys back to the key holder, so if you have compromised the client sufficiently to obtain the (transport) keys then presumably you already have access to the keys being transported. This further reduces the importance of forward secrecy.\r\n\r\nThis is right. Generally, any centrally generated key or revocation passphrase relys on the security of the keys used to protect its delivery. The point for psf is, that one could cash or sniff the communication and at a later point in time decrypts the encrypted value and so get access to the new keymaterial. Finally it is also a mater of security of the algorithms used to protect the delivery of the encrypted values and the encrypted keys themselves.\r\n@ounsworth Do you think we should change something in the text?",
          "createdAt": "2023-06-13T14:57:33Z",
          "updatedAt": "2023-06-13T15:00:20Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 15.6.23\r\nIssue can be closed",
          "createdAt": "2023-06-15T15:48:44Z",
          "updatedAt": "2023-06-15T15:48:44Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOInbtzM5Z6paC",
      "title": "No need for `id-hpke-mac` and `HpkeMacParameter` nor for key identifiers",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/3",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, [section  5.1.3.4 ](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.1.3.4 ) contains the definitions\r\n\r\n> ```\r\n>   id-hpke-mac OBJECT IDENTIFIER ::= { TBD2 }\r\n> ```\r\n> When id-hpke-mac is used, the parameters MUST employ the HpkeMacParameter syntax. The syntax for HpkeMacParameter is as follows:\r\n> ```\r\n>   HpkeMacParameter ::= SEQUENCE {\r\n>      mac                 AlgorithmIdentifier\r\n>      -- the MAC AlgId\r\n>   }\r\n> ```\r\nI see no need for these.\r\n\r\nAny MAC-based message protection is sufficiently determined by the algorithm identifier of the MAC alg used for the given message and by (the selection of) the symmetric key being used. This general case is already covered by [section 5.1.3.1](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-shared-secret-information) and by the beginning of [section 5.1.1 ](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-pki-message-header) giving hints on how to address the symmetric key.\r\nFor instance, for the PBM defined in [RFC 4211 section 4.4](https://www.rfc-editor.org/rfc/rfc4211#section-4.4), the set of core algorithms and auxiliary values (such as the salt) used are encoded in a `PBMParameter` structure, and the shared secret may be implicit or determined by `sender` field, plus optionally the `senderKID` field, of the message header. This way, the message protection can be interpreted without further input/history.\r\n[moved to #6:]~BTW, IMO it would be helpful if section 5.1.1 also mentioned how to determine the symmetric key being used, namely using the `sender` and `senderKID` message header fields.~\r\n\r\n[moved to #6:]~Actually, the HPKE+MAC-based message protection is 'just' another special case of the MAC-based message protection very briefly described in section 5.1.3.1. So IMO all the text of  5.1.3.4 should better move there (strictly speaking, as a subsection of 5.1.3.1, but I'd say we can and should save the extra nesting).~\r\n\r\nThe only special/new thing about this MAC method is how to arrive at the shared symmetric key.\r\nHere its is not a pre-shared one, but it is produced on-the-fly using a preparatory message exchange with the KEM cert and the respective KEM key pair of each party.\r\n\r\nWhen the first two messages have been exchanged, the symmetric 'session' key to use for MAC-protecting all further messages of the given transaction has been established. Note that because it is ephemeral, it cannot be (sufficiently) addressed by any static info such as the sender/recipient name and/or the sender/recipient cert or their subject key identifiers (SKID).\r\nTherefore, it does not really help to place the SKID anywhere in the message, be it as part of the `HpkeMacParameter` structure or as the the `senderKID` and `recipKID` message header fields.\r\n\r\nAnyway, the established symmetric 'session' key needs to be remembered by both parties as long as the transaction is active. Therefore, it must be stored along with their transaction contexts, and it is entirely sufficient to identify/address this symmetric 'session' key using the `transactionID`.\r\n\r\nThe fact that all messages starting with the third one are protected using a symmetric key established by then \r\nis implicitly clear for the rest of the transaction. So semantically there is no need to give any indication about this (such as `id-hpke-mac`) in the protected messages. OTOH, for technical reasons some protection alg identifier should be given, and it is most straightforward to place the MAC alg identifier directly in the `protectionAlg` field. (BTW, the sender of each message could even choose a different MAC algorithm each time, though this flexibility is not needed.)\r\n\r\nThus, for the reasons given, `id-hpke-mac` and `HpkeMacParameter` are not needed,\r\nneither do we need any way of further referencing the KEM certs and keys used in the first steps.",
      "createdAt": "2022-12-22T21:07:49Z",
      "updatedAt": "2023-01-19T13:46:22Z",
      "closedAt": "2023-01-19T13:46:21Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "David, thank you for this issue.\r\nYou point at some additional issues unrelated to the topic in the tile. Please open separate issues, it makes it easier to separately discuss them. It confuses me to mx things. thank you.\r\n\r\nI support you proposal to directly use the MAC algorithm OID instead of id-hpke-mac in the protectionAlg field of the request message. I will provide an update of the text reflecting this change and we can possibly discuss it in the afternoon. ",
          "createdAt": "2023-01-19T08:41:10Z",
          "updatedAt": "2023-01-19T08:41:10Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> You point at some additional issues unrelated to the topic in the tilte. Please open separate issues, it makes it easier to separately discuss them. It confuses me to mix things. thank you.\r\n\r\nI noticed two such topics - done for them.\r\n \r\n> I support you proposal to directly use the MAC algorithm OID instead of id-hpke-mac in the protectionAlg field of the request message. I will provide an update of the text reflecting this change and we can possibly discuss it in the afternoon.\r\n\r\nPleased to hear.",
          "createdAt": "2023-01-19T09:39:49Z",
          "updatedAt": "2023-01-19T09:39:49Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved in https://github.com/lamps-wg/cmp-updates/commit/ec4fa3e3b120a151a3448a0e17490957424b587c",
          "createdAt": "2023-01-19T13:46:21Z",
          "updatedAt": "2023-01-19T13:46:21Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOInbtzM5Z6pbr",
      "title": "Open point in Key Encapsulation section: how to convey L?",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/4",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "How does the recipient of an `HpkeCiphertext` know/learn the value of  the length `L` that the sender chose in its call of `SendExportBase`, to be re-used in the `ReceiveExportBase` call of the recipient?",
      "createdAt": "2022-12-22T21:07:56Z",
      "updatedAt": "2023-02-28T08:23:46Z",
      "closedAt": "2023-02-28T08:23:46Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "L is the output length of the KDF in byte and therefore the length of the secret derived from the HPKE. This secret will be used for MAC-based message protection using a MAC algorithm according to CMP Algorithms Section 6.2 https://datatracker.ietf.org/doc/html/draft-ietf-lamps-cmp-algorithms-15#section-6.2 . Therefore, I think, L is specified by the length of the symmetric key to be used by the MAC algorithm.\r\n@Mike, is this understanding correct, or do you think we need to explicitly specify L in the HpkeCiphertext?",
          "createdAt": "2023-01-19T09:18:58Z",
          "updatedAt": "2023-01-19T09:18:58Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Design team meeting minutes:\r\nI will add L to HpkeCiphertext and make enc optional.\r\nThe client needs to send an HpkeCiphertext  with kem, kdf, and L omitting enc in the first genm message.\r\nThe server should accept the L an include into the HpkeCiphertext  of the genp message.\r\nThe client must check that the L from genp is at least as large as the security level of the chosen MAC algorithm.",
          "createdAt": "2023-01-19T17:19:19Z",
          "updatedAt": "2023-01-19T17:23:01Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I mentioned in \\#2 that if we include the overall transcript in the final key derivation (as recommended in the Kyber paper), then that maybe solves the problem of the client and server using different L values.",
          "createdAt": "2023-01-20T00:10:11Z",
          "updatedAt": "2023-01-20T18:25:27Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will add L to HpkeCiphertext.",
          "createdAt": "2023-02-28T08:23:46Z",
          "updatedAt": "2023-02-28T08:23:46Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOInbtzM5Z8OB5",
      "title": "Be consistent: client - server vs. PKI entity - PKI management entity",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/5",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[Section 5.1.3.4. ](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.1.3.4)[Key Encapsulation](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-key-encapsulation) uses both pairs of terms interchangeably.\r\n\r\nFor consistency, better stick to one of them. My preference, for simplicity, would be: client - server.\r\nThe terms \"client\" and \"server\" are those used also in, e.g., section 5.1.1, and various other places.",
      "createdAt": "2022-12-23T06:37:07Z",
      "updatedAt": "2023-02-28T12:41:05Z",
      "closedAt": "2023-02-28T12:41:04Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right, this is confusing.\r\nPKI entity and PKI management entity refer to the parties involved in the PKI management operation. We use these terms in the Lightweight CMP Profile. RFC4210 uses the terms end entity and PKI, CA, or RA. Client and server refer to the role in a single exchange where one has the client and one the server role. Client and server is also used in RFC 4210, but less often that end entity and PKI/CA/RA. Therefore, I tend to use end entity and PKI if the roles in the PKI management operation are meant. ",
          "createdAt": "2023-01-19T09:35:02Z",
          "updatedAt": "2023-01-19T09:35:02Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "I just found that at least according to RFC 4210, \"PKI entity\" can mean any PKI component: CA, RA, or EE. \r\nSo certainly better to use \"end entity\" and \"PKI\" than \"PKI entity\".\r\n\r\nYet regarding the HPKE-baesd message flow described in 5.1.3.4,\r\nthis is not actually confined to EE - PKI communication: it can be used also, e.g., between (L)RA and RA, or RA and CA.\r\nSo also for this generality I propose to use \"client\" and \"server\" here and to mention that the client usually is an EE and the server a PKI management entity.",
          "createdAt": "2023-01-19T09:53:56Z",
          "updatedAt": "2023-01-19T09:53:56Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> this is not actually confined to EE - PKI communication: it can be used also, e.g., between (L)RA and RA, or RA and CA.\r\n\r\nThis is why I used PKI entity here instead of end entity, as it can be the EE, RA, or CA, as you stated above.",
          "createdAt": "2023-01-19T14:20:55Z",
          "updatedAt": "2023-01-19T14:20:55Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I could add (client) and (server) in Figure 2 like\r\n\r\nStep# PKI entity (client)                  PKI management entity (server)\r\n\r\nfor clarification.",
          "createdAt": "2023-01-19T14:24:13Z",
          "updatedAt": "2023-01-19T14:24:13Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Design team meeting minutes:\r\nI will add a note right after Figure 2 to state that the PKI entity has kemCertC and the PKI management entity has kemCertS.\r\nI will also add PKI entity after the first occurrence of clinet with kemCertC and the same for PKI management entity. ",
          "createdAt": "2023-01-19T17:21:38Z",
          "updatedAt": "2023-01-19T17:22:43Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Design team meeting minutes: I will add a note right after Figure 2 to state that the PKI entity has kemCertC and the PKI management entity has kemCertS. I will also add PKI entity after the first occurrence of clinet with kemCertC and the same for PKI management entity.\r\n\r\nImplemented",
          "createdAt": "2023-02-28T12:41:04Z",
          "updatedAt": "2023-02-28T12:41:04Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOInbtzM5cUN9p",
      "title": "Clarify in section 5.1.1 how to determine the symmetric key being used",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/6",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[this issue has been carved out from #3]\r\n\r\nIt would be helpful if section 5.1.1 also mentioned how to determine the symmetric key being used, \r\nnamely using the `sender` and `senderKID` message header fields.",
      "createdAt": "2023-01-19T09:34:22Z",
      "updatedAt": "2023-05-10T12:12:59Z",
      "closedAt": "2023-05-10T12:12:59Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is already a ToDo in the text to add some content to the description of senderKID and recipKID. My proposal would be to use the subjectKID of the KEM certificates used by the end entity and the PKI.\r\nWhat do you think? ",
          "createdAt": "2023-01-19T09:38:20Z",
          "updatedAt": "2023-01-19T09:38:20Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> There is already a ToDo in the text to add some content to the description of senderKID and recipKID.\r\n\r\nYou mean `< ToDo: Possibly add a protection mechanism using KEM keys. >`?\r\n\r\nThe recipKID is not needed for KEM keys.\r\n\r\n> My proposal would be to use the subjectKID of the KEM certificates used by the end entity and the PKI. What do you think?\r\n\r\nSo you mean, to place in the `senderKID` field the subject key identifier (SKID) of the KEM cert used by the respective sender?\r\n\r\nCertainly it is preferable to use the SKID if it is available, so I support requiring its use in this case.\r\nYet note that RFC 5280 requires its presence in X.509v3 compliant certs only for CA certs.\r\nSo we should also mention somehow that the `sender` field may be used if needed. \r\nWhich is already stated by RFC 4210 (though not specifically for symmetric keys) and inherited in 5.1.1:\r\n\r\n> The sender field contains the name of the sender of the PKIMessage. This name (in conjunction with senderKID, if supplied) should be sufficient to indicate the key to use to verify the protection on the message. ",
          "createdAt": "2023-01-19T10:16:28Z",
          "updatedAt": "2023-01-19T10:16:28Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we need two HPKE exchanges to establish a shared secret capable authenticating the server and the client, the KEM certificates of both sides are needed, like with D-H. Therefore, I think we need to use both senderKID and recipKID.\r\nWe can discuss later in our meeting.",
          "createdAt": "2023-01-19T14:08:55Z",
          "updatedAt": "2023-01-19T14:13:06Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Design team meeting minutes:\r\nThis issue was not discussed.",
          "createdAt": "2023-01-19T17:22:28Z",
          "updatedAt": "2023-01-19T17:22:28Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "done",
          "createdAt": "2023-03-01T07:57:16Z",
          "updatedAt": "2023-03-01T07:57:16Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DDvO can you please check if this is what you requested?",
          "createdAt": "2023-03-02T17:03:44Z",
          "updatedAt": "2023-03-02T17:03:44Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DDvO Ping",
          "createdAt": "2023-05-09T13:15:13Z",
          "updatedAt": "2023-05-09T13:15:13Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we changed to unilateral authenticated KEM key establishment, there is no need to identify a KEM key from the recipient. Therefore in Section 5.1.1 the subsentence in parentheses\r\n`(recipKID will normally only be required where protection of the message also uses the recipient's KEM key)`\r\nmust be removed.",
          "createdAt": "2023-05-10T11:22:19Z",
          "updatedAt": "2023-05-10T11:22:19Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Actually better return to the original subsentence in parentheses referring to DH keys:\r\n`(recipKID will normally only be required where protection of the message uses Diffie-Hellman (DH) keys)`\r\n\r\nsuch that the paragraph becomes\r\n\r\n> senderKID and recipKID are usable to indicate which keys have been used to protect the message (recipKID will normally only be required where protection of the message uses Diffie-Hellman (DH) keys). These fields MUST be used if required to uniquely identify a key (e.g., if more than one key is associated with a given sender name). The senderKID SHOULD be used in any case.\r\n\r\n",
          "createdAt": "2023-05-10T11:47:19Z",
          "updatedAt": "2023-05-10T11:47:19Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "done",
          "createdAt": "2023-05-10T12:12:59Z",
          "updatedAt": "2023-05-10T12:12:59Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOInbtzM5cUPGj",
      "title": "Move all of section 5.1.3.4 into section 5.1.3.1 ?",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/7",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[this issue was carved out of #3]\r\n\r\nThe HPKE+MAC-based message protection is 'just' another special case of the MAC-based message protection very briefly described in section 5.1.3.1. So IMO all the text of 5.1.3.4 should better move there (strictly speaking, as a subsection of 5.1.3.1, but I'd say we can and should save the extra nesting).",
      "createdAt": "2023-01-19T09:38:07Z",
      "updatedAt": "2023-01-19T14:12:13Z",
      "closedAt": "2023-01-19T14:12:12Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Currently Section 5.1.3 is structured based on the keys to use for message protection. Here we use KEM keys for message protection and only use a symmetric key indirectly, like with Diffie-Hellmann in Section 5.1.3.2. I would propose to rename Section 5.1.3.1 to focus it more on pre-shared keys and passwords and keep the protection using KEM keys in Section 5.1.3.4.",
          "createdAt": "2023-01-19T09:43:38Z",
          "updatedAt": "2023-01-19T09:43:38Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Sounds good to me.",
          "createdAt": "2023-01-19T10:18:49Z",
          "updatedAt": "2023-01-19T10:18:49Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved with https://github.com/lamps-wg/cmp-updates/commit/92bacd31fa196e317930b6e2197c3f3673dd75bd",
          "createdAt": "2023-01-19T14:12:12Z",
          "updatedAt": "2023-01-19T14:12:12Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOInbtzM5c3axo",
      "title": "Using HPKE SetupBase+KDF, HPKE SendExportBase, or plain KEM+KDF",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/8",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-celi-wiggers-tls-authkem-01#section-3.1 uses SetupExport.\r\nhttps://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.1.3.4 uses SendExportBase.\r\nAre there reasons for using SetupExport + KDF instead of SendExportBase?",
      "createdAt": "2023-01-26T11:59:52Z",
      "updatedAt": "2023-05-09T13:00:10Z",
      "closedAt": "2023-05-09T13:00:10Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The WG recommended use of HPKE for establishing a shared secret key.  Today HPKE specifies only a D-H bases KEM in RFC9180 Section 4.1.  To be independent to HPKE this document could also use the approach shown in https://datatracker.ietf.org/doc/draft-ietf-lamps-cms-kemri/ only relying on the availability of a KeyGen, Encapsulate, and Decapsulate function.  This would ease this specification and allow further reuse of profiling KEM algorithms for use in CMS.  What do others think? ",
          "createdAt": "2023-03-01T07:58:26Z",
          "updatedAt": "2023-03-01T08:00:19Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Authors meeting 3.2.23:\r\nI will submit a version including the HPKE SendExportBase based approach and then I will provide an update providing the plain KEM+KDF approach as this is the preferred choice of the group.",
          "createdAt": "2023-03-02T17:06:45Z",
          "updatedAt": "2023-03-02T17:06:45Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The change to plain KEM+KDF will be submitted with version -05 ",
          "createdAt": "2023-03-03T07:45:12Z",
          "updatedAt": "2023-03-03T07:45:12Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The changes to plain KEM+KDF was presented to IETF116 and supported",
          "createdAt": "2023-05-09T13:00:10Z",
          "updatedAt": "2023-05-09T13:00:10Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOInbtzM5c3cA1",
      "title": "Is there a planning for adding a Kyber profile to HPKE",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/9",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/rfc9180#section-4.1 offers a DH profile for HPKE. Is there any activity ongoing to provide a Kyber based profile.",
      "createdAt": "2023-01-26T12:04:11Z",
      "updatedAt": "2023-03-02T17:08:53Z",
      "closedAt": "2023-03-02T17:08:52Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ounsworth could you ask this question at IETF116 CRFG meeting if you are on-site?",
          "createdAt": "2023-01-26T16:19:41Z",
          "updatedAt": "2023-01-26T16:19:41Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 2.3.23:\r\nWhen moving away from HPKI to plain KEM+KDF, we do not rely on HPKE supporting any specific KEM algorithm.\r\nBut anyhow, it would be interesting if CRFG will profile Kyber for HPKE. ",
          "createdAt": "2023-03-02T17:08:52Z",
          "updatedAt": "2023-03-02T17:08:52Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOInbtzM5du1Qh",
      "title": "Proof of Possession: \"certain attacks\"",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/10",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": ">[4.3. ](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-4.3)[Proof-of-Possession (POP) of Private Key](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-proof-of-possession-pop-of-)\r\n> In order to prevent _certain attacks_ [...]\r\n\r\n(emphasis mine)\r\n\r\nWe've had quite a bit of discussion about \"certain attacks\" on the mailing list. The remainder of the text hints a bit at attacks in deployments where the binding between the end entity and the key isn't rigorously checked, but does it make sense to e.g. refer to [Appendix A of this paper](https://s3.amazonaws.com/files.douglas.stebila.ca/files/research/papers/CCS-GHLOSZ22.pdf) which makes a little bit more of an overview?\r\n\r\n(This comment comes from my academic writing background, so leaving this or other references out for editorial reasons is perfectly fine)",
      "createdAt": "2023-02-06T13:19:47Z",
      "updatedAt": "2023-05-17T14:37:00Z",
      "closedAt": "2023-05-17T14:37:00Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh hey, I wrote Appendix A of that paper.\r\n+1 to this suggestion!",
          "createdAt": "2023-02-23T01:15:41Z",
          "updatedAt": "2023-02-23T01:15:54Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ounsworth do you want to add a security consideration briefly describing the risk/attack a POP addresses bases on Appendix A of that paper?",
          "createdAt": "2023-02-27T13:52:34Z",
          "updatedAt": "2023-02-27T13:52:34Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Authors meeting 2.3.23:\r\nMike will provide a summary as security consideration.",
          "createdAt": "2023-03-02T16:08:47Z",
          "updatedAt": "2023-03-02T16:08:47Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "concluded with Mike's PR",
          "createdAt": "2023-05-17T14:37:00Z",
          "updatedAt": "2023-05-17T14:37:00Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOInbtzM5du4z_",
      "title": "4.3.4 PoP of KEM keys: mention encaps/decaps?",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/11",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> [4.3.4. ](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-4.3.4)[Key Encapsulation Mechanism Keys](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-key-encapsulation-mechanism)\r\n\r\n> [...]\r\n> The indirect method is to issue a certificate that is encrypted for the end entity (and have the end entity demonstrate its ability to decrypt this certificate in the confirmation message). This allows a CA to issue a certificate in a form that can only be used by the intended end entity.\r\n\r\nI'm nitpicking a bit, but perhaps it makes sense to clarify that we encrypt the certificate using a shared key encapsulated to the private key, and that the ciphertext needs to be provided along the certificate as well.\r\n\r\nFor example:\r\n\r\n> The indirect method is to issue a certificate that is encrypted for the end entity using a shared secret key encapsulated to the private key (and have the end entity demonstrate its ability to decapsulate the shared secret key from the ciphertext and decrypt this certificate in the confirmation message). This allows a CA to issue a certificate in a form that can only be used by the intended end entity.\r\n\r\nA bit verbose, perhaps, but it may help clarify that the KEM mechanism does differ from the encryption key mechanism in this important way.",
      "createdAt": "2023-02-06T13:28:35Z",
      "updatedAt": "2023-03-03T07:56:16Z",
      "closedAt": "2023-03-03T07:56:16Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for this proposal.\r\nWhen using the indirect method, the encrypted certificate is provided using EnvelopedData. This implies providing an encrypted content encryption key. But certainly it is good to explicitly state usage of encyps/decaps here.\r\nFinally it is even more complex as the shared secret key is derived from the encypsulated key using a KDF :-)\r\n\r\n`The indirect method is to issue a certificate that is encrypted for the end entity using a shared secret key derived from a key encapsulated using its public key (and have the end entity demonstrate its ability to use its private key for decapsulation of the KEM ciphertext, derive the shared secret key, decrypt this certificate, and provide a hash of the certificate in the confirmation message).  This allows a CA to issue a certificate in a form that can only be used by the intended end entity.`",
          "createdAt": "2023-03-01T08:29:12Z",
          "updatedAt": "2023-03-01T08:29:12Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 2023-3-2:\r\nYou could borrow the KEM definition from either\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-hybrid-design#name-key-encapsulation-mechanism\r\n\r\nor \r\n\r\nhttps://datatracker.ietf.org/doc/draft-ietf-lamps-cms-kemri/\r\nsection 1",
          "createdAt": "2023-03-02T16:14:26Z",
          "updatedAt": "2023-03-02T16:14:26Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding `Note: A definition of Key Encapsulation Mechanisms can be found in {{I-D.ietf-cms-kemri, Section 1}}.`",
          "createdAt": "2023-03-03T07:55:54Z",
          "updatedAt": "2023-03-03T07:55:54Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOInbtzM5dvKyk",
      "title": "Security considerations: Interactions with Certificate Transparency",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/14",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The implicit method of proof-of-possession, for encryption key- and KEM-based certificates, relies on the end-entity not obtaining the issued certificate if they do not posses the private key to decrypt the certificate.\r\n\r\nThis means that a certificate _is_ created and, if CMP is used to issue WebPKI certificates, recorded to the certificate transparency logs: after all, we need to include the SCT statements in the certificate. Most submitters will likely submit precertificates instead of full certificates (which, in CT 1.0, include the poison precertificate extension, or in CT 2.0, use CMS syntax). But normal certificates _can_ be submitted, and if they are submitted before the PoP is completed, the certificate can be obtained from the CT logs: see for example this cert (which does have the poison extension https://crt.sh/?id=8512435380)",
      "createdAt": "2023-02-06T14:15:04Z",
      "updatedAt": "2023-03-03T08:07:32Z",
      "closedAt": "2023-03-03T08:07:31Z",
      "comments": [
        {
          "author": "thomwiggers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This comment is an extension of the discussion we had on the mailing list https://mailarchive.ietf.org/arch/msg/tls/McnWDK1UQ_hSNRwGg8mjHD0tWEY/",
          "createdAt": "2023-02-06T14:17:34Z",
          "updatedAt": "2023-02-06T14:17:34Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right, using CT logs is a special case.\r\n\r\nCurrently Section 3.1.2 writes\r\n`Note that policy may dictate that the CA must not publish or otherwise distribute the certificate until the requesting entity has reviewed and accepted the newly-created certificate (typically through use of the certConf message).` \r\nI would propose extending the sentence to \r\n`Note that policy may dictate that the CA must not publish or otherwise distribute the certificate until the requesting entity has reviewed and accepted the newly-created certificate or the indirect POP is completed (typically through use of the certConf message). In case of publication of the certificate or a precertificate in a Certificate Transparency log [RFC9162], the certificate must be revoked if it was not accepted or the indirect POP could not be completed.`\r\n\r\nAlso Section 4.2.2.2 states\r\n`(Where verification of the cert confirmation message fails, the RA/CA MUST revoke the newly issued certificate if it has been published or otherwise made available.)`\r\n\r\nBut I would also add a security consideration:\r\n`8.9 Usage of Certificate Transparency Logs\r\nIf a certificate or its precertificate was published in a Certificate Transparency log [RFC9162] it must be revoked, if a required certConf message could not be verified, especially when the implicit POP was used.`",
          "createdAt": "2023-03-01T09:36:49Z",
          "updatedAt": "2023-03-01T09:36:49Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest we add an additional sentence to this security consideration:\r\n\r\n> CAs that support indirect PoP MUST NOT also publish final certificates to CT logs. The risk is that a malicious actor could fetch the final certificate from the CT log and use that to spoof a response to the implicit PoP challenge via a certConf response. This risk does not apply to CT precertificates, so those are ok to publish.",
          "createdAt": "2023-03-02T16:42:12Z",
          "updatedAt": "2023-03-02T16:42:12Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Extended the security considerations as proposed by Mike",
          "createdAt": "2023-03-03T08:07:31Z",
          "updatedAt": "2023-03-03T08:07:31Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOInbtzM5fpKRR",
      "title": "Additional PKIFailureInfo badKemExchange?",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/15",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ToDo in Section 5.1.3.4: An additional PKIFailureInfo badKemExchange could be defined and used alternatively. ",
      "createdAt": "2023-03-01T09:48:48Z",
      "updatedAt": "2023-03-02T16:40:08Z",
      "closedAt": "2023-03-02T16:40:07Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Authors meeting 2.3.23:\r\nWe go with badMessageCheck",
          "createdAt": "2023-03-02T16:40:07Z",
          "updatedAt": "2023-03-02T16:40:07Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOInbtzM5fpKlZ",
      "title": "Adding l and mac to HpkeCiphertext ",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/16",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ToDo in Section 5.1.3.4: As discussed in the last meeting and according to [draft-ietf-lamps-cms-kemri] I added the explicit value of l.  I also propose adding the mac OID.  What do others think?",
      "createdAt": "2023-03-01T09:49:43Z",
      "updatedAt": "2023-03-02T16:41:00Z",
      "closedAt": "2023-03-02T16:40:59Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 2.3.23:\r\nkeep L\r\nremove mac ",
          "createdAt": "2023-03-02T16:40:59Z",
          "updatedAt": "2023-03-02T16:40:59Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOInbtzM5fpL28",
      "title": "Adding support for KEM to Section 5.2.8",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/17",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ToDo in Section 5.2.8: Adding support for KEM keys and fixing some inconsistencies in Section 5.2.8.3 resulting from the update of RFC2510 to RFC4210\r\n",
      "createdAt": "2023-03-01T09:52:52Z",
      "updatedAt": "2024-02-26T15:40:52Z",
      "closedAt": "2024-02-26T15:40:52Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 2.3.23:\r\nDo this after IETF116",
          "createdAt": "2023-03-02T16:43:15Z",
          "updatedAt": "2023-03-02T16:43:15Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Looks like this is still ToDo.",
          "createdAt": "2023-05-25T07:24:35Z",
          "updatedAt": "2023-05-25T07:25:06Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, we need to look into it ... :-)",
          "createdAt": "2023-05-25T07:31:17Z",
          "updatedAt": "2023-05-25T07:31:17Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please review updates updated Section 5.2.8 (see fa57a14f292affa3a60be051cc7c1eb318320aff)",
          "createdAt": "2024-01-08T16:31:58Z",
          "updatedAt": "2024-01-08T16:31:58Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@johngray-dev will review this\r\nAlso with focus on encryptedRand",
          "createdAt": "2024-01-22T17:48:12Z",
          "updatedAt": "2024-01-22T17:48:12Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From Section 5.2.8.3 of RFC4210 says\r\n\"Alternatively, the POP can use the POPOSigningKey structure\r\n   given in [[CRMF](https://www.rfc-editor.org/rfc/rfc4210#ref-CRMF)] (where the alg field is DHBasedMAC and the signature\r\n   field is the MAC) as a fourth alternative for demonstrating POP if\r\n   the CA already has a D-H certificate that is known to the EE.\"\r\n\r\nI shifted and rephrased this to Section 5.2.8 of rfc4210bis\r\n\"In the special case that the CA/RA has a D-H certificate that is known to the EE and the certification request is for a key agreement key pair, the EE can also use the POPOSigningKey structure (where the algorithmIdentifier field is DHBasedMAC and the signature field is the MAC) for demonstrating POP.\" \r\n\r\n@johngray-dev Do you know, why the MAC is not placed in POPOPrivKey agreeMAC?\r\nShould we change this?",
          "createdAt": "2024-01-24T13:32:04Z",
          "updatedAt": "2024-01-24T13:32:04Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "We discussed this on February 22nd and 26th.   The text around using CMPv3 when this field is used will mitigate any backwards compatibility issues.   Mike had comments about the size of the integer as well as possibly using it to decode an arbitrary CMS message.  The previous challenge was an OCTET_STRING.  It is now an Enveloped data format which would contain many other fields as a structure which would be unlikely to be able to be decoded arbitrarily.  ",
          "createdAt": "2024-02-26T15:38:33Z",
          "updatedAt": "2024-02-26T15:38:33Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOInbtzM5fpMqQ",
      "title": "Appendix B would needs a review",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/18",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ToDo: Review Appendix B and try to push the content to Section 4 or Section 5 of this document.\r\nToDo: Possibly add support for certificates containing KEM keys.\r\n",
      "createdAt": "2023-03-01T09:54:24Z",
      "updatedAt": "2024-01-08T16:30:35Z",
      "closedAt": "2024-01-08T16:30:34Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 3.2.23:\r\nAddress after IETF116",
          "createdAt": "2023-03-02T16:44:25Z",
          "updatedAt": "2023-03-02T16:44:25Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Looks like this is due meanwhile.\r\nWho should ideally review this?",
          "createdAt": "2023-05-25T07:23:10Z",
          "updatedAt": "2023-05-25T07:23:10Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is still a ToDo. Probably we need to digg into it a bit :-)",
          "createdAt": "2023-05-25T07:30:33Z",
          "updatedAt": "2023-05-25T07:30:33Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated Appendix B with fa57a14f292affa3a60be051cc7c1eb318320aff",
          "createdAt": "2024-01-08T16:30:34Z",
          "updatedAt": "2024-01-08T16:30:34Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOInbtzM5lc4Lf",
      "title": "Review of updates Section 5.1.3.4 and Appendix E",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/20",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I updates the section on mesage protection using a KEM key pair and added an appendisx on different szenarios regarding which side owns the KEM key.\r\n\r\nAny review is appreciated.",
      "createdAt": "2023-05-09T13:42:52Z",
      "updatedAt": "2023-05-12T11:38:12Z",
      "closedAt": "2023-05-12T11:38:12Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 11.05.23\r\nImprove the first paragraphe regadring terminoligy 'sender' and 'recipient'.\r\nMay be add  som text like Mike proposed:\r\n\"Here we use the term \"sender\" to mean the entity initiating a given request, who needs to be authenticated, and \"recipient\" to mean the entity who needs to authenticate the request being received. In case the sender ...\"",
          "createdAt": "2023-05-11T15:37:58Z",
          "updatedAt": "2023-05-11T15:37:58Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mike proposed adding a note explaining why Bob used the KDF not together with the KEM.",
          "createdAt": "2023-05-12T08:14:48Z",
          "updatedAt": "2023-05-12T08:14:48Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It was aslo discussed to extend the description of steps 1-3 of figure 2 more explicitly, like in older versions of the document.",
          "createdAt": "2023-05-12T08:15:50Z",
          "updatedAt": "2023-05-12T08:15:50Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "done",
          "createdAt": "2023-05-12T11:38:12Z",
          "updatedAt": "2023-05-12T11:38:12Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOInbtzM5lj-yk",
      "title": "Rename KemCiphertext  to e.g. KemCiphertextInfo",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/21",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Feedback from Andreas",
      "createdAt": "2023-05-10T13:23:37Z",
      "updatedAt": "2023-05-11T15:38:18Z",
      "closedAt": "2023-05-11T15:38:18Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Change is implemented",
          "createdAt": "2023-05-11T15:38:18Z",
          "updatedAt": "2023-05-11T15:38:18Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOInbtzM5lkHx2",
      "title": "Review definition of len",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/22",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is the sentence \r\n`It SHOULD be the maximum key length of the MAC function and MUST NOT be larger that 255*Nh of the KDF where Nh is the output size of the KDF.`\r\nstill correct and needed.\r\nIt came from HPKE and it requires the sender of the ciphertext to know the MAC function to be used for protection. ",
      "createdAt": "2023-05-10T13:43:03Z",
      "updatedAt": "2023-05-12T08:11:02Z",
      "closedAt": "2023-05-12T08:11:02Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Remove kdf and len from KemCiphertextInfo and introduce a KEMBMParameter Alg OID containing kdf, len, and mac.",
          "createdAt": "2023-05-11T15:58:10Z",
          "updatedAt": "2023-05-11T15:58:10Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "done, see #26 ",
          "createdAt": "2023-05-12T08:11:02Z",
          "updatedAt": "2023-05-12T08:11:02Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOInbtzM5lkJEw",
      "title": "Can we use Alice and Bob within an RFC with regard to inclusive language ",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/23",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Alternatively we could use 'Peer A' and 'Peer B'",
      "createdAt": "2023-05-10T13:46:01Z",
      "updatedAt": "2023-05-12T08:13:06Z",
      "closedAt": "2023-05-12T08:13:06Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ralienpp checkt with IETF regarding usage of Alice and Bob. The feedback is, that usage of Alice and Bob is fine regarding inclusive language.",
          "createdAt": "2023-05-12T08:13:06Z",
          "updatedAt": "2023-05-12T08:13:06Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOInbtzM5lkX98",
      "title": "Security Consideration according to KEM",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/24",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Potentially add something like in cms-kemri: KEM algorithms that offer indistinguishability under adaptive chosen ciphertext attack (IND-CCA2) security are appropriate",
      "createdAt": "2023-05-10T14:16:59Z",
      "updatedAt": "2023-05-24T13:58:01Z",
      "closedAt": "2023-05-24T13:58:01Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 11.05.23\r\nPotentially add this topic to CMP Algorithms",
          "createdAt": "2023-05-11T16:00:19Z",
          "updatedAt": "2023-05-11T16:00:19Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal from John on email:\r\n\r\nIn CMS KEM draft-ietf-lamps-cms-kemri we have the following note:\r\n\r\nTo be appropriate for use with this specification, the KEM algorithm\r\nMUST explicitly be designed to be secure when the public key is used\r\nmany times. For example, a KEM algorithm with a single-use public\r\nkey is not appropriate because the public key is expected to be\r\ncarried in a long-lived certificate [RFC5280] and used over and over.\r\nThus, KEM algorithms that offer indistinguishability under adaptive\r\nchosen ciphertext attack (IND-CCA2) security are appropriate. A\r\ncommon design pattern for obtaining IND-CCA2 security with public key\r\nreuse is to apply the Fujisaki-Okamoto (FO) transform [FO] or a\r\nvariant of the FO transform [HHK].\r\n\r\nWe could probably reuse some or most of this text because it is possible a CMP server or client could use a KEM key for a long period of time for message protection. We could recommend the server rotate its protection keys periodically to mitigate this issue (I think that would be a best practice). Therefore a KEM with a limited use key would not be acceptable, and an IND-CCA2 KEM should be recommended.",
          "createdAt": "2023-05-12T12:17:23Z",
          "updatedAt": "2023-05-12T12:17:23Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue will be addressed in the context of #25 ",
          "createdAt": "2023-05-24T13:58:00Z",
          "updatedAt": "2023-05-24T13:58:00Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOInbtzM5lkbGf",
      "title": "Data threshold for message protection",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/25",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Do we want to add a generic security consideration on how much data shall be protected using one key.",
      "createdAt": "2023-05-10T14:23:56Z",
      "updatedAt": "2023-06-15T16:01:32Z",
      "closedAt": "2023-06-15T16:01:32Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 11.05.23\r\nJohn offerd to look into it.",
          "createdAt": "2023-05-11T16:02:17Z",
          "updatedAt": "2023-05-11T16:02:17Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "In CMS KEM draft-ietf-lamps-cms-kemri we have the following note: \r\n\r\nTo be appropriate for use with this specification, the KEM algorithm\r\n   MUST explicitly be designed to be secure when the public key is used\r\n   many times.  For example, a KEM algorithm with a single-use public\r\n   key is not appropriate because the public key is expected to be\r\n   carried in a long-lived certificate [RFC5280] and used over and over.\r\n   Thus, KEM algorithms that offer indistinguishability under adaptive\r\n   chosen ciphertext attack (IND-CCA2) security are appropriate.  A\r\n   common design pattern for obtaining IND-CCA2 security with public key\r\n   reuse is to apply the Fujisaki-Okamoto (FO) transform [FO] or a\r\n   variant of the FO transform [HHK].\r\n\r\nWe could probably reuse some or most of this text because it is possible a CMP server or client *could* use a KEM key for a long period of time for message protection.   We could recommend the server rotate its protection keys periodically to mitigate this issue (I think that would be a best practice).  Therefore a KEM with a limited use key would not be acceptable, and an IND-CCA2 KEM should be recommended. ",
          "createdAt": "2023-05-11T19:23:23Z",
          "updatedAt": "2023-05-11T19:23:23Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for this proposal. I extended the text a little to\r\n\"Recurring Usage of KEM Keys for Message Protection\r\n\r\nA shared secret key (ssk) used for MAC-based message protection MUST\r\nonly be used for the PKI management operation indicated by the\r\ntransactionID in the KemOtherInfo.\r\n\r\nIt is assumed that the overall size of data of all CMP messages in a\r\nPKI management operation protected by one shared secret key is small\r\nand not introducing additional security risks.\r\n\r\nTo be appropriate for use with this specification, the KEM algorithm\r\nMUST explicitly be designed to be secure when the public key is used\r\nmany times. For example, a KEM algorithm with a single-use public\r\nkey is not appropriate because the public key is expected to be\r\ncarried in a long-lived certificate [RFC5280] and used over and over.\r\nThus, KEM algorithms that offer indistinguishability under adaptive\r\nchosen ciphertext attack (IND-CCA2) security are appropriate. A\r\ncommon design pattern for obtaining IND-CCA2 security with public key\r\nreuse is to apply the Fujisaki-Okamoto (FO) transform [Fujisaki] or a\r\nvariant of the FO transform [Hofheinz].\"\r\n\r\n@johngray-dev what do you think?",
          "createdAt": "2023-05-22T15:32:32Z",
          "updatedAt": "2023-05-22T15:32:32Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "To me this sounds good.\r\nI'd suggest Just a re-phrase of the 2nd paragraph to:\r\n\r\nIt is assumed that the overall data size of the CMP messages\r\nin a PKI management operation protected by a single ssk\r\nis small enough not to introduce extra security risks.",
          "createdAt": "2023-05-25T07:20:47Z",
          "updatedAt": "2023-05-25T07:20:47Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the proposal.",
          "createdAt": "2023-05-25T07:29:37Z",
          "updatedAt": "2023-05-25T07:29:37Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good to me too. \r\n\r\nI suggest adding a summary sentence to the end of the IND-CCA2 paragraph:\r\n> Therefore, given a long-term public key using an IND-CCA2 secure KEM algorithm, there is no limit to the number of CMP messages that can be encrypted under it.",
          "createdAt": "2023-06-07T18:31:29Z",
          "updatedAt": "2023-06-07T18:37:31Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the suggested edits.   They look good to me.    Therefore, to summarize all the changes:\r\n\r\n\"Recurring Usage of KEM Keys for Message Protection\r\n\r\nA shared secret key (ssk) used for MAC-based message protection MUST\r\nonly be used for the PKI management operation indicated by the\r\ntransactionID in the KemOtherInfo.\r\n\r\nIt is assumed that the overall data size of the CMP messages\r\nin a PKI management operation protected by a single shared secret key\r\nis small enough not to introduce extra security risks.\r\n\r\nTo be appropriate for use with this specification, the KEM algorithm\r\nMUST explicitly be designed to be secure when the public key is used\r\nmany times. For example, a KEM algorithm with a single-use public\r\nkey is not appropriate because the public key is expected to be\r\ncarried in a long-lived certificate [RFC5280] and used over and over.\r\nThus, KEM algorithms that offer indistinguishability under adaptive\r\nchosen ciphertext attack (IND-CCA2) security are appropriate. A\r\ncommon design pattern for obtaining IND-CCA2 security with public key\r\nreuse is to apply the Fujisaki-Okamoto (FO) transform [Fujisaki] or a\r\nvariant of the FO transform [Hofheinz].  \r\n\r\nTherefore, given a long-term public key using an IND-CCA2 secure KEM\r\nalgorithm, there is no limit to the number of CMP messages that can \r\nbe encrypted under it.\"",
          "createdAt": "2023-06-07T18:38:10Z",
          "updatedAt": "2023-06-07T18:38:10Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A shared secret key (ssk) used for MAC-based message protection MUST\r\n> only be used for the PKI management operation indicated by the\r\n> transactionID in the KemOtherInfo.\r\n\r\nIt is right, that one ssk shall only be used for one PKI management operation. But I struggle with 'indicated by  ...', specifically as the transactionID is optional.\r\nMay be we can rephrase.\r\n\r\n`Each PKI management operation MUST use a fresh KEM cyphertext (ct)  and therefore a frech shared secret key (ssk) for MAC-based message protection.`",
          "createdAt": "2023-06-13T16:19:15Z",
          "updatedAt": "2023-06-13T16:19:15Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Yeah, unfortunately we cannot fully rely on the presence of the transactionID.\r\n\r\nI suggest focusing on `ssk` only:\r\n\r\n```\r\nThe shared secret key (ssk) used for MAC-based message protection must be fresh for each PKI management operation.\r\n```\r\nbecause this is what matters more directly\r\nand also is what we refer to in the related statement\r\n> This shared secret key ssk can be reused by Alice for MAC-based protection of further messages sent to Bob within the current PKI management operation.",
          "createdAt": "2023-06-14T06:53:24Z",
          "updatedAt": "2023-06-14T06:53:24Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "I also suggest moving the new sentence just after the related one in 5.1.3.4, simply as follows:\r\n> Yet it MUST be fresh per each PKI management operation.\r\n",
          "createdAt": "2023-06-14T07:11:05Z",
          "updatedAt": "2023-06-14T07:11:05Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I prefere refering to using a fresh `ct` as it is clearer and anyhow results in a fresh `ssk`.",
          "createdAt": "2023-06-14T14:04:40Z",
          "updatedAt": "2023-06-14T14:04:40Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What do you think of this proposal as first paragraphe for Section 8.8.\r\n`Each PKI entity using key encapsulation for message protection, see {{sect-5.1.3.4}}, MUST receive a fresh KEM ciphertext (ct) for each PKI management operation to derive a fresh shared secret key (ssk) for MAC-based message protection.`",
          "createdAt": "2023-06-14T14:56:05Z",
          "updatedAt": "2023-06-14T14:56:05Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After exchange with @DDvO this is the final proposal:\r\n`Each PKI entity using key encapsulation for MAC-based message protection, see {{sect-5.1.3.4}}, MUST use a fresh KEM ciphertext (ct) for each PKI management operation to derive a fresh shared secret key (ssk).`",
          "createdAt": "2023-06-15T06:15:10Z",
          "updatedAt": "2023-06-15T06:15:10Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 15.6.23\r\nAs the freshnes of the (ct) cannot be ensured by Alice, it is recommended to use randomn recipNonces in the message requesting the (ct).\r\n\r\n`Each PKI entity using key encapsulation for MAC-based message protection, see [Section 5.1.3.4], MUST use a fresh shared secret key (ssk) for each PKI management operation. This can be enforced by using senderNonce and recipNonce header fields in all messages of the PKI management operation.`",
          "createdAt": "2023-06-15T15:20:19Z",
          "updatedAt": "2023-06-15T15:59:44Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 15.6.23 \r\nIssue can be closed after the update",
          "createdAt": "2023-06-15T15:51:43Z",
          "updatedAt": "2023-06-15T15:51:43Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOInbtzM5lwLaf",
      "title": "Introduction of KemBMParameter",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/26",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Meeting 11.5.23\r\nIt was decided to introduce an new AlgID for KEM based message protection\r\n`  id-KemBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 TBD4}\r\n\r\n  KemBMParameter ::= SEQUENCE {\r\n    kdf              AlgorithmIdentifier{KEY-DERIVATION, {...}},\r\n    len              INTEGER (1..MAX),\r\n    mac              AlgorithmIdentifier{MAC-ALGORITHM, {...}}\r\n  }`",
      "createdAt": "2023-05-12T07:45:15Z",
      "updatedAt": "2023-11-27T11:50:03Z",
      "closedAt": "2023-11-27T11:50:03Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is id-PasswordBasedMac OBJECT IDENTIFIER ::= { 1 2 840 113533 7 66 13 } and id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}, see: http://oid-info.com/get/1.2.840.113533.7.66\r\n\r\n@johngray-dev @ounsworth As both OIDs are registered in the Entrust OID tree, is it possible that Entrust will could also register id-KemBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 TBD4}?",
          "createdAt": "2023-05-12T07:54:23Z",
          "updatedAt": "2023-05-12T07:54:23Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "done",
          "createdAt": "2023-05-12T08:10:24Z",
          "updatedAt": "2023-05-12T08:10:24Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is id-PasswordBasedMac OBJECT IDENTIFIER ::= { 1 2 840 113533 7 66 13 } and id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}, see: http://oid-info.com/get/1.2.840.113533.7.66\r\n\r\n@johngray-dev @ounsworth As both OIDs are registered in the Entrust OID tree, is it possible that Entrust will could also register id-KemBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 TBD4}?",
          "createdAt": "2023-05-23T11:11:37Z",
          "updatedAt": "2023-05-23T11:18:05Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\n1.2.840.113533.7.66.16  kemBasedMac\r\n```\r\n\r\nI guess the others, like id-passwordBasedMac are Entrust OIDs; they were never registered under the IANA PKIX arc, so I guess it makes sense for this one also (ie this is not a prototyping OID, but actually the final OID). Good.",
          "createdAt": "2023-06-07T18:51:28Z",
          "updatedAt": "2023-06-07T18:51:28Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good.   I am not sure if we have to officially register it anywhere, but it has been registered in the same place internally.   I guess if IETF accepts it, that makes it official.   Perhaps I will go over to the IANA people at 117 and ask them about it just to be clear....  :)",
          "createdAt": "2023-06-07T18:52:43Z",
          "updatedAt": "2023-06-07T18:52:43Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 15.6.23\r\nWe keep this issue until we have feedback from Russ on our proposal using the Entrust OID.",
          "createdAt": "2023-06-15T15:50:52Z",
          "updatedAt": "2023-06-15T15:50:52Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "2023-06-16:\r\n> John:\r\nThe problem with placeholder OIDs is that some implementions never move to the \"production\" OID.  If Entrust wants to assign permanent ones, I have no objection.\r\nRuss\r\n\r\nI think we can go ahead and use the OID mentioned above:\r\n\r\n```\r\n1.2.840.113533.7.66.16  kemBasedMac\r\n```\r\n",
          "createdAt": "2023-06-18T15:33:37Z",
          "updatedAt": "2023-06-18T15:33:37Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, Agreed.   I is in an Arc that we own, and we have reserved space of it.   So sure, we can make it permanent.\r\n",
          "createdAt": "2023-06-23T16:42:34Z",
          "updatedAt": "2023-06-23T16:42:34Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOInbtzM5l8WSM",
      "title": "Add clarification to Section 5.1.1.4. - CertProfile",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/28",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Liao Lijun adked the following question:\r\n\r\n\"As stated in \" 2.4. New Section 5.1.1.3. - CertProfile\":\r\n\r\n   id-it-certProfile  OBJECT IDENTIFIER ::= {id-it 21}\r\n   CertProfileValue ::= SEQUENCE SIZE (1..MAX) OF UTF8String\r\n\r\nWhen used in an ir/cr/kur/genm, the value MUST NOT contain more elements than the number of CertReqMsg or InfoTypeAndValue elements and the certificate profile names refer to the elements in the given order.\r\n\r\nMy question is how to interpret the profile names if the names in the CertProfileValue field is less than the CertReqMsg? For example, there are 4 CertReqMsg entries, but only 3 values in CertProfileValue.\"",
      "createdAt": "2023-05-15T15:18:20Z",
      "updatedAt": "2023-06-20T06:19:37Z",
      "closedAt": "2023-06-20T06:19:37Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My feedback was:\r\n\"If you have multiple certReqMsg in an ir/cr/kur/p10cr, you should use the certProfile names in the same order. If you have no certProfile for one or several certReqMsg you can put theses either at the end of the sequence in the ir/cr/kur/p10cr or add a \u201c\u201d (empty string) as certProfile name to the sequence.\"\r\n\r\nWe should add a correcponding note to the rfc4210bis.",
          "createdAt": "2023-05-15T15:19:12Z",
          "updatedAt": "2023-05-15T15:19:12Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added this text to Section 5.1.1.4\r\n\r\n\"If you have multiple certReqMsg in an ir/cr/kur/p10cr, you MUST use the certProfile names in the same order as the certReqMsg. If you have no certProfile for one or several certReqMsg you can put theses either at the end of the sequence in the ir/cr/kur/p10cr or add an empty string as certProfile name to the sequence.\"\r\n\r\n@johngray-dev @DDvO @xipki Do you have any comments?",
          "createdAt": "2023-05-22T15:45:20Z",
          "updatedAt": "2023-05-22T15:45:20Z"
        },
        {
          "author": "xipki",
          "authorAssociation": "NONE",
          "body": "Looks fine for me.\n\nLijun\n\nHendrik Brockhaus ***@***.***> schrieb am Mo., 22. Mai 2023,\n17:45:\n\n> I added this text to Section 5.1.1.4\n>\n> \"If you have multiple certReqMsg in an ir/cr/kur/p10cr, you MUST use the\n> certProfile names in the same order as the certReqMsg. If you have no\n> certProfile for one or several certReqMsg you can put theses either at the\n> end of the sequence in the ir/cr/kur/p10cr or add an empty string as\n> certProfile name to the sequence.\"\n>\n> @johngray-dev <https://github.com/johngray-dev> @DDvO\n> <https://github.com/DDvO> @xipki <https://github.com/xipki> Do you have\n> any comments?\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/lamps-wg/cmp-updates/issues/28#issuecomment-1557461369>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABWFTMHDDK6VDZLZFZOD74LXHOCZXANCNFSM6AAAAAAYCLHK44>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-05-22T16:15:56Z",
          "updatedAt": "2023-05-22T16:15:56Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> I added this text to Section 5.1.1.4\r\n\r\nThis change is not (yet) visible at https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md\r\nI suppose the new text is meant to be placed after this sentence:\r\n> When used in an ir/cr/kur/genm, the value MUST NOT contain more elements than the number of CertReqMsg or InfoTypeAndValue elements and the certificate profile names refer to the elements in the given order.\r\n\r\nand before this sentence:\r\n> When used in a p10cr, the value MUST NOT contain multiple certificate profile names.\r\n\r\nSo far, it supposedly reads as:\r\n\r\n> If you have multiple certReqMsg in an ir/cr/kur/p10cr, you MUST use the certProfile names in the same order as the certReqMsg. If you have no certProfile for one or several certReqMsg you can put theses either at the end of the sequence in the ir/cr/kur/p10cr or add an empty string as certProfile name to the sequence.\r\n\r\nWe should not use \"you\" in the spec.\r\n\r\nI propose re-combining and re-phrasing these text sections as follows:\r\n\r\nWhen used in a p10cr message, the sequence MUST NOT contain multiple certificate profile names.\r\nWhen used in an ir/cr/kur/genm message, the sequence MUST NOT contain more certificate profile names \r\nthan the number of CertReqMsg or InfoTypeAndValue elements contained in the message body,\r\n\r\nThe certificate profile names in the sequence relate to the CertReqMsg or InfoTypeAndValue elements in the given order. An empty string has the same meaning as if no element is present at the given sequence position: \r\nno certificate profile name being associated with the respective CertReqMsg or InfoTypeAndValue element.\r\n",
          "createdAt": "2023-05-24T14:36:03Z",
          "updatedAt": "2023-05-24T14:36:03Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @DDvO for your proposal.\r\nAre there any further comments?\r\n\r\n@johngray-dev Anything from your side?",
          "createdAt": "2023-05-24T15:53:46Z",
          "updatedAt": "2023-05-24T15:54:19Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "  The original text seemed clear to me, but I see where the question could come from, so I agree we should try to clarify without making it more complicated.  The updated message from David is good, I was going to suggest we make it clear that when CertProfile is required by one or more CertReqMsg, either the Cert profile Name or an empty string (to indicate no profile name), MUST be present in the same order.   So effectively we are saying they must have the same number of elements.  However, I think we still should allow a more efficient use case:\r\n\r\nFor example, say you have 3 certReqMsg (this is a common and supported use-case at Entrust).   Say you want to use a cert profile for only the 2nd certReqMsg.   The most efficient structure would be a Sequence of 2 CertProfiles (the first one being the empty string, the second one containing the profile name). Anything else should not be required.   The first one requires the empty String to act as a placeholder, but if all the ones at the end don't require it, then it shouldn't be needed.\r\n\r\nIn practise, the most efficient structure would be for the client to re-order the 3 certReqMsg so that the first one was the one that required the cert profile.   Then they would only need a CertProfileValue sequence of 1 as the 2nd and 3rd would both be empty.  Forcing them to send empty ASN.1 sequences is just a waste of bytes.\r\n\r\nI can try to come up with some text to see if that can be further clarified if you agree that this type of efficiency makes sense.    Or for the sake of simplicity and clarity, we could just say when CertProfile is used, it MUST contain the same number of sequence elements as the number of CertReqMsg, and where no Cert profile name is required, an Empty String must be used as a placeholder... ",
          "createdAt": "2023-06-15T12:45:19Z",
          "updatedAt": "2023-06-15T12:48:22Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we are aligned on the issue. If you propose a leaner wording, it will be fine.",
          "createdAt": "2023-06-15T14:21:47Z",
          "updatedAt": "2023-06-15T14:21:47Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Meeting 15.6.23\r\nJohn will review and potentially add some text.",
          "createdAt": "2023-06-15T15:49:57Z",
          "updatedAt": "2023-06-15T15:49:57Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this covers all the bases.  I also added clarity by specifically mentioned the names of the structures so it is clear what is being discussed.  \r\n\r\nWhen used in a p10cr message, the CertProfileValue sequence MUST NOT contain multiple certificate profile names.  When used in an ir/cr/kur/genm message, the CertProfileValue sequence MUST NOT contain more certificate profile names than the number of CertReqMsg or GenMsgContent InfoTypeAndValue elements contained in the message body.\r\n\r\nThe certificate profile names in the CertProfileValue sequence relate to the CertReqMsg or GenMsgContent InfoTypeAndValue elements in the given order. An empty string means no certificate profile name is associated with the respective CertReqMsg or GenMsgContent InfoTypeAndValue element.  If the CertProfileValue sequence contains less certificate profile entries than CertReqMsg or GenMsgContent InfoTypeAndValue elements, the remaining CertReqMsg or GenMsgContent InfoTypeAndValue elements have no profile name associated with them.   ",
          "createdAt": "2023-06-16T16:44:44Z",
          "updatedAt": "2023-06-16T16:48:25Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you John. I will update the section accordingly.",
          "createdAt": "2023-06-20T06:03:05Z",
          "updatedAt": "2023-06-20T06:03:05Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOInbtzM5qHxsi",
      "title": "KEM protection is hard to follow and understand",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/30",
      "state": "CLOSED",
      "author": "Akretsch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "- https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md#key-encapsulation refers to https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md#variants-of-using-kem-keys-for-pki-message-protection-sect-e for implementation details. The implementer has to jump between both sections to get an sufficient understanding.\r\n- KEM protection can be used only between two PKI entities (hop to hop) and the protection cannot  be validated by third PKI entities (end to end)? So always a reprotection is needed to keep integrity?\r\n- https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md#variants-of-using-kem-keys-for-pki-message-protection-sect-e shows some message flows:\r\n  -  Please make more clear that one message flow is covered by one transaction. \r\n  - Please specify more in detail the required content of genm, genp and request.\r\n  -  The first message flow introduces KEM certificates: \r\n     - How to obtain, how to validate such certificates? \r\n     - How the right certificate to use can identified in extraCerts?\r\n     - Should the chain also be in extraCerts?\r\n  - The second message flow seems to use KEM keys without certificate:   \r\n    - What means \"protection depending on available key material\"?\r\n    - How the PKI Entitiy (Bob) obtains the authenticated public key? Could this replace the KEM certificates in the first message flow too?\r\n  - The third message flow shows a failed transaction.\r\n    - How Bob identifies the right KEM certificate in extraCerts?\r\n\r\n  \r\n ",
      "createdAt": "2023-06-29T09:06:16Z",
      "updatedAt": "2023-07-10T11:11:33Z",
      "closedAt": "2023-07-10T11:11:28Z",
      "comments": [
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Thank you for this interesting feedback.\r\n\r\nFor managing the various points mentioned, it would have helped to provide at least the three rather unrelated outer items in separate issues. I am not allowed to edit the above text, but I copied the text of your first two items to #32 and #33 and partly amended it there.",
          "createdAt": "2023-06-29T10:37:32Z",
          "updatedAt": "2023-06-29T14:19:00Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "It remains in this issue here to comment on the last item referring to [Appendix E:](https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md#variants-of-using-kem-keys-for-pki-message-protection-sect-e):\r\n\r\n> Please make more clear that one message flow is covered by one transaction.\r\n\r\nI suggest adding this text, which also provides further clarification how the given message flows should be understood:\r\n\r\n\"For any PKI management operation started by a PKI entity with any type of `request` message, the following message flows describe the adaptations needed to support the use of a KEM key. There are three cases to distinguish, namely whether the PKI entity or the by PKI management entity uses a KEM key, and whether in the latter case the PKI entity already knows initially the KEM key of the PKI management entity. In case both sides use KEM keys, adaptations need to be combined such that for each direction a shared secret is established\"\r\n\r\n> Please specify more in detail the required content of genm, genp and request.\r\n\r\nIn the first message flow, I suggest two small additions.\r\n* extend \"format unprotected genm\" to \"format unprotected genm with empty PKIBody\".\r\n(BTW, this 'empty' genm will look much like the genm described in https://www.rfc-editor.org/rfc/rfc4210#appendix-E.5, but confusion is avoided because the latter sort of genm is required to be protected.)\r\n* extend \"KEM ciphertext in PKIBody\" to \"KEM ciphertext as the only InfoTypeAndValue in PKIBody\".\r\n\r\nIn the second message flow, I suggest extending \"KEM ciphertext in generalInfo\" to  \"KEM ciphertext in generalInfo of PKIHeader\"\r\n\r\nBTW, I suggest replacing in the third message flow \"as shown in Figure 4 above\" by \"as shown in the Figure before\" because the constant number 4 cannot be a assumed to be fixed/correct.\r\n\r\n> The first message flow introduces KEM certificates:\r\n> How to obtain, how to validate such certificates?\r\n\r\nThey should be obtained as usual by a CA, which of course needs to support producing certs for KEM public keys.\r\nThe validation of such a cert and its chain does not depend on the KEM key in the EE cert.\r\n\r\n> How the right certificate to use can identified in extraCerts?\r\n> Should the chain also be in extraCerts?\r\n\r\nI suggest clarifying this by replacing  \"containing KEM certificate in extraCerts\" by\r\n\"with extraCerts consisting of the KEM certificate followed by this chain\" and similarly in the third message flow.\r\n\r\n> The second message flow seems to use KEM keys without certificate:\r\n\r\nThere we do not make assumptions where the public KEM key comes from,\r\nbut usually the client will have obtained it before from the server as part of a KEM certificate.\r\n\r\n> What means \"protection depending on available key material\"?\r\n\r\nThis just means that the entity protects its message in the usual way:\r\nIf it has a signature key, it uses this, or else it uses MAC-based protection,\r\nusing any pre-shared secret or shared symmetric key derived by (EC)DH \r\nor also using a key derived via KEM (in the opposite direction).\r\n\r\n> How the PKI Entity (Bob) obtains the authenticated public key?\r\n\r\nBy any means, for instance as described in the third message flow.\r\n\r\n> Could this replace the KEM certificates in the first message flow too?\r\n\r\nNo, the first message flow is for using KEM in the opposite direction.\r\n\r\n> The third message flow shows a failed transaction.\r\n\r\nNot quite - the error message here just indicates to the client \r\nthat it needs to use the KEM key contained in the extraCerts.\r\n\r\nBTW, unfortunately the failInfo code is somewhat misleading because \r\n`wrongIntegrity` is normally used to indicate that the protection by the PKI entity is wrong,\r\nbut here it indicates the inability of the PKI management entity to protect its first response using KEM.\r\nHere I propose using a new, to-the-point `failInfo` code or some other indication for this special case,\r\nfor example giving no `failInfo` field, which would be less confusing than using `wrongIntegrity`.\r\n\r\nWhether the PKI entity sees this error as a termination of the PKI management operation\r\nor uses the same transaction ID for the subsequent `request` is not specified and looks like it does no matter.\r\n\r\n> How Bob identifies the right KEM certificate in extraCerts?\r\n\r\nAs before: it should be stated that it must be in the first extraCert (and followed by the respective chain).",
          "createdAt": "2023-07-04T14:59:55Z",
          "updatedAt": "2023-07-04T15:19:55Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Issue resolved with above mentioned commit",
          "createdAt": "2023-07-10T11:11:28Z",
          "updatedAt": "2023-07-10T11:11:28Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOInbtzM5qIHTW",
      "title": "Section 5.1.1.4: clarify restriction on number of certProfile elements",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/31",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For clarity, please replace\r\n\r\n> When used in an ir/cr/kur/genm message, the CertProfileValue sequence MUST NOT contain more certificate profile names than the number of CertReqMsg or GenMsgContent InfoTypeAndValue elements contained in the message body.\r\n\r\nby, e.g.,\r\n\r\n> When used in an ir/cr/kur message, the number of profile names in the CertProfileValue sequence MUST NOT exceed the number of CertReqMsg elements contained in the message body.\r\nSimilarly, when used in a genm message, this number MUST NOT exceed the number of InfoTypeAndValue elements in the message body.",
      "createdAt": "2023-06-29T10:08:08Z",
      "updatedAt": "2023-07-10T11:29:11Z",
      "closedAt": "2023-07-10T11:29:10Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am uncertain if this change is needed.\r\nI feel like the text is correct and ciscumvents dublication of text.\r\n\r\n> For clarity, please replace\r\n> \r\n> > When used in an ir/cr/kur/genm message, the CertProfileValue sequence MUST NOT contain more certificate profile names than the number of CertReqMsg or GenMsgContent InfoTypeAndValue elements contained in the message body.\r\n> \r\n> by, e.g.,\r\n> \r\n> > When used in an ir/cr/kur message, the number of profile names in the CertProfileValue sequence MUST NOT exceed the number of CertReqMsg elements contained in the message body.\r\n> > Similarly, when used in a genm message, this number MUST NOT exceed the number of InfoTypeAndValue elements in the message body.\r\n\r\nRFC4211 definiert: CertReqMessages ::= SEQUENCE SIZE (1..MAX) OF CertReqMsg\r\nRFC4210 definiert: GenMsgContent ::= SEQUENCE OF InfoTypeAndValue\r\n\r\nWe want to say that the number of elements in CertProfileValue must not be larger than the number of element in CertReqMessages or GenMsgContent. So maybe we could rephrase like this.\r\n\r\n`When used in an ir/cr/kur/genm message, the CertProfileValue sequence MUST NOT contain more certificate profile names than the number of elements in the CertReqMessages or GenMsgContent sequence.`\r\n\r\n@johngray-dev As this text was contributed from you, what do you think?\r\nBTW, this change may also affect the next paragraphe.",
          "createdAt": "2023-06-29T11:10:19Z",
          "updatedAt": "2023-06-29T11:10:19Z"
        },
        {
          "author": "RufusJWB",
          "authorAssociation": "NONE",
          "body": "There must be a misunderstanding. This:\r\n\r\n> > When used in an ir/cr/kur/genm message, the CertProfileValue sequence MUST NOT contain more certificate profile names than the number of CertReqMsg or GenMsgContent InfoTypeAndValue elements contained in the message body.\r\n\r\nis not the actual text from https://datatracker.ietf.org/doc/draft-ietf-lamps-cmp-updates/23/ chapter 2.4 . There you write \r\n\r\n>    When used in an ir/cr/kur/genm, the value MUST NOT contain more\r\n>    elements than the number of CertReqMsg or InfoTypeAndValue elements\r\n>    and the certificate profile names refer to the elements in the given\r\n>    order.\r\n\r\nAnd one more question: what happens if the number of elements in the CertProfileValue sequence is neither 1 nor the number of CertReqMsg but smaller than the number of CertReqMsg. For example there are two values in the CertProfileValue sequence but three CertReqMsg. Wouldn't it be more reasonable to say, that the number of elements in the CertProfileValue sequence needs to be either 1 or exactly the number of CertReqMsg?",
          "createdAt": "2023-06-29T13:41:14Z",
          "updatedAt": "2023-06-29T13:42:01Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding rfc4210bis, this topic was already discussed and concluded in #28.\r\nCMP-Updates was approved a year ago, but there are some changes from the AD review of the Lightweight CMP Profile in the pipeline for AUTH48.\r\nRfc4210bis shall include the changes from CMP Updates and will obsolete this document when published.\r\nIf there is no change request regarding rfc4210bis, we should close this issue here.",
          "createdAt": "2023-06-29T13:51:29Z",
          "updatedAt": "2023-06-29T13:51:29Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue was mainly about the wording in [Section 2.4 of V23 of CMP Updates](https://datatracker.ietf.org/doc/html/draft-ietf-lamps-cmp-updates-23#section-2.4).\r\n\r\nThe current text in [Section 5.1.1.4 of rfc4210bis](https://datatracker.ietf.org/doc/html/draft-ietf-lamps-rfc4210bis-07#section-5.1.1.4) seams to be sufficient.",
          "createdAt": "2023-07-10T11:29:10Z",
          "updatedAt": "2023-07-10T11:29:10Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOInbtzM5qIQro",
      "title": "Overall structure of spec for KEM use should be improved",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/32",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "@Akretsch wrote in #30:\r\n\r\n> https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md#key-encapsulation refers to https://github.com/lamps-wg/cmp-updates/blob/main/draft-ietf-lamps-rfc4210bis.md#variants-of-using-kem-keys-for-pki-message-protection-sect-e for implementation details. The implementer has to jump between both sections to get an sufficient understanding.\r\n\r\nOne more point to add on this, which he also mentioned to me this morning: \r\nThe security considerations section 8.8: https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-recurring-usage-of-kem-keys contains an important functional requirement:\r\n> Each PKI entity using key encapsulation for MAC-based message protection, see [Section 5.1.3.4](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#sect-5.1.3.4), MUST use a fresh shared secret key (ssk) for each PKI management operation.\r\n\r\nIMO this should be given already in Section 5.1.3.4 because otherwise this can easily be overlooked by implementers focusing on the main body of the spec, so regarding KEM use on Section 5.1.3.4.",
      "createdAt": "2023-06-29T10:34:24Z",
      "updatedAt": "2023-07-10T08:51:03Z",
      "closedAt": "2023-07-10T08:51:02Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Appendix E contains additional explanation, but no normative text. To have the base-specification in Section 5.1.3.4 not too large, this additional guidance was shifted on purpose to an appendix.\r\n\r\nRegarding Security Considerations: It is never a good idea to overlook the Security considerations section. See also [cms-kemri](https://datatracker.ietf.org/doc/draft-ietf-lamps-cms-kemri/) draft for similar examples for normative text in the Security Considerations section.",
          "createdAt": "2023-07-10T08:51:02Z",
          "updatedAt": "2023-07-10T08:51:02Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOInbtzM5qIQtI",
      "title": "Point out that KEM-based message protection is limited to one hop",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/33",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When discussing our spec in section 5.1.3.4. etc. with our first implementer @Akretsch, he pointed out an interesting issue that at least I had not noticed before, as he meanwhile wrote in #30:\r\n\r\n> KEM protection can be used only between two PKI entities (hop to hop) and the protection cannot be validated by third PKI entities (end to end)? So always a reprotection is needed to keep integrity?\r\n\r\nI fear that the answer to all three questions is 'yes',\r\nand if so, we should point this out in our text.",
      "createdAt": "2023-06-29T10:34:30Z",
      "updatedAt": "2023-07-04T10:25:07Z",
      "closedAt": "2023-07-04T10:25:07Z",
      "comments": [
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "As discussed over lunch today, this is a general problem also with other forms of MAC-based protection.\r\nIt is not something we need to handle at 4210bis level, but should in any update to the LCMPP\r\nwhere so far we assume that (more or less) all PKI entities have/use keys that are capable of signing.",
          "createdAt": "2023-07-04T10:23:50Z",
          "updatedAt": "2023-07-04T10:23:50Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOInbtzM5zqKh3",
      "title": "Add in Section 5.1.3.5. (Multiple Protection) a cross-reference to Section 5.1.1.3. (OrigPKIMessage)",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/34",
      "state": "CLOSED",
      "author": "DDvO",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As discussed with @HBrock today, we wanna add to the end of [Section 5.1.3.5](https://datatracker.ietf.org/doc/html/draft-ietf-lamps-rfc4210bis#section-5.1.3.5) something like the following:\r\n\r\nIn case an RA needs to modify a request message, it MAY include the original PKIMessage in the generalInfo field of the modified message as described in [Section 5.1.1.3](https://datatracker.ietf.org/doc/html/draft-ietf-lamps-rfc4210bis#section-5.1.1.3).",
      "createdAt": "2023-10-12T17:05:54Z",
      "updatedAt": "2023-11-27T12:24:35Z",
      "closedAt": "2023-11-27T12:24:35Z",
      "comments": []
    },
    {
      "number": 35,
      "id": "I_kwDOInbtzM50GR_k",
      "title": "Clarify usage of transactionID in KEM use cases",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/35",
      "state": "CLOSED",
      "author": "kiron-mx",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "HBrock"
      ],
      "labels": [],
      "body": "In a discussion with @HBrock we concluded that the use of the `transactionID` field in the PKI header should be more clarified for KEM-based message protection.\r\n\r\nCurrently, the `transactionID` is an optional field of the `KemOtherInfo` datastructure. Now, the specification of `transactionID` in Section 5.1.1 allows the following scenario:\r\nWhen the PKI entity knows that the PKI management entity uses a KEM key pair and has the authentic public key (Appendix E, Fig. 4), the transaction can be reduced a single request/response pair (if `implicitConfirm` is used). In that case, no `transactionID` is required. Since the `transactionID` is only an optional parameter of the `KemOtherInfo` data structure, this may result in a KDF context with the KEM ciphertext as the only source of entropy (in the absence of senderNonce and recipNonce).\r\n\r\nSuggestion:\r\nThere could be a note in Section 5.1.3.4 recommending (or even mandating) the usage of `transactionID`. This would make the `transactionID` a mandatory field of `KemOtherInfo`.\r\nDoing so, a higher entropy of the KDF context and consequently, of the shared secret key (ssk) can be achieved in the absence of senderNonce and recipNonce.\r\n\r\nAs Section 5.1.1 describes all usage scenarios of the `transactionID` field, it should be appended with the treatment of the field in KEM use cases.",
      "createdAt": "2023-10-17T16:23:11Z",
      "updatedAt": "2024-01-19T15:57:17Z",
      "closedAt": "2024-01-19T15:57:17Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOInbtzM51slG1",
      "title": ":== --> ::=",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/37",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "  id-it-KemCiphertextInfo OBJECT IDENTIFIER ::= { id-it TBD1 }\r\n  KemCiphertextInfoValue :== KemCiphertextInfo\r\n-->\r\n  id-it-KemCiphertextInfo OBJECT IDENTIFIER ::= { id-it TBD1 }\r\n  KemCiphertextInfoValue ::= KemCiphertextInfo",
      "createdAt": "2023-11-02T16:28:18Z",
      "updatedAt": "2023-11-27T10:09:35Z",
      "closedAt": "2023-11-27T10:09:35Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed in https://github.com/lamps-wg/cmp-updates/commit/c7986b2a41d872e872028a5329f8f0ea4d8470d3\r\n",
          "createdAt": "2023-11-27T10:09:35Z",
          "updatedAt": "2023-11-27T10:09:35Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOInbtzM56a2XF",
      "title": "Shall EnvelopedDate be offered for encrypting Rand in POPODecKeyChallContent?",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/38",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The challenge field in popdecc messages is supposed to contain Rand in encrypted form.\r\nSee RFC 9480 Appendix A and RFC 4210 Section 5.2.8.3.\r\n\r\n```\r\nPOPODecKeyChallContent ::= SEQUENCE OF Challenge\r\n-- One Challenge per encryption key certification request (in the\r\n-- same order as these requests appear in CertReqMessages)\r\n\r\nChallenge ::= SEQUENCE {\r\n    owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\r\n                            OPTIONAL,\r\n    -- MUST be present in the first Challenge; MAY be omitted in\r\n    -- any subsequent Challenge in POPODecKeyChallContent (if\r\n    -- omitted, then the owf used in the immediately preceding\r\n    -- Challenge is to be used)\r\n    witness             OCTET STRING,\r\n    -- the result of applying the One-Way Function (owf) to a\r\n    -- randomly generated INTEGER, A (Note that a different\r\n    -- INTEGER MUST be used for each Challenge.)\r\n    challenge           OCTET STRING\r\n    -- the encryption (under the public key for which the cert.\r\n    -- request is being made) of Rand\r\n}\r\n\r\n-- Rand was added in CMP Updates [RFC9480]\r\n\r\nRand ::= SEQUENCE {\r\n-- Rand is encrypted under the public key to form the challenge\r\n-- in POPODecKeyChallContent\r\n   int                  INTEGER,\r\n   -- the randomly generated INTEGER A (above)\r\n   sender               GeneralName\r\n   -- the sender's name (as included in PKIHeader)\r\n}\r\n\r\nPOPODecKeyRespContent ::= SEQUENCE OF INTEGER\r\n-- One INTEGER per encryption key certification request (in the\r\n-- same order as these requests appear in CertReqMessages).  The\r\n-- retrieved INTEGER A (above) is returned to the sender of the\r\n-- corresponding Challenge.\r\n``` \r\n\r\nCurrently it is poorly specified which encryption key and encryption algorithm is used. To support also KEM-keys and to improve the clarity of the specification, Challenge could be extended to also be capable using EnvelopedData for transferring the encrypted Rand.\r\n\r\n```\r\nPOPODecKeyChallContent ::= SEQUENCE OF Challenge\r\n-- One Challenge per certification request (in the same order\r\n-- as these requests appear in CertReqMessages)\r\n\r\nChallenge ::= SEQUENCE {\r\n    owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\r\n                            OPTIONAL,\r\n    -- MUST be present in the first Challenge; MAY be omitted in\r\n    -- any subsequent Challenge in POPODecKeyChallContent (if\r\n    -- omitted, then the owf used in the immediately preceding\r\n    -- Challenge is to be used)\r\n    witness             OCTET STRING,\r\n    -- the result of applying the One-Way Function (owf) to a\r\n    -- randomly generated INTEGER, A (Note that a different\r\n    -- INTEGER MUST be used for each Challenge.)\r\n    challenge           OCTET STRING\r\n    -- MUST be used for CMP V1 and V2 popdecc messages\r\n    -- MUST be an empty OCTET STRING for CMP V3 popdecc\r\n    -- messages\r\n    -- The encryption (under the public key for which the certification\r\n    -- request is being made) of Rand\r\n     encRand             EnvelopedData    OPTIONAL\r\n    -- MUST be omitted for CMP V 1 and V2 popdecc messages\r\n    -- MUST be used for CMP V3 messages and contain the encrypted\r\n    -- value of Rand\r\n    -- Using Challenge omitting the optional encRand is bit-compatible\r\n    -- to the syntax without this change.\r\n}\r\n\r\n-- Rand was added in CMP Updates [RFC9480]\r\n\r\nRand ::= SEQUENCE {\r\n-- Rand is encrypted under the public key to form the challenge\r\n-- in POPODecKeyChallContent\r\n   int                  INTEGER,\r\n   -- the randomly generated INTEGER A (above)\r\n   sender               GeneralName\r\n   -- the sender's name (as included in PKIHeader)\r\n}\r\n\r\nPOPODecKeyRespContent ::= SEQUENCE OF INTEGER\r\n-- One INTEGER per certification request (in the same order\r\n-- as these requests appear in CertReqMessages).  The\r\n-- retrieved INTEGER A (above) is returned to the sender of the\r\n-- corresponding Challenge.\r\n```\r\n\r\nBut I am uncertain if it is worth doing this, because I am not aware of any implementation using popdecc messages.\r\n",
      "createdAt": "2023-12-22T12:31:29Z",
      "updatedAt": "2024-01-08T16:29:35Z",
      "closedAt": "2024-01-08T16:29:35Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated Section 5.2.8 with fa57a14f292affa3a60be051cc7c1eb318320aff",
          "createdAt": "2024-01-08T16:29:35Z",
          "updatedAt": "2024-01-08T16:29:35Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOInbtzM58n7rA",
      "title": "Content of KemOtherInfo in Section 5.1.3.4",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/39",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Decide on the content of KemOtherInfo decpending on the conclusions taken in cms-kemri\r\nThe goal is to use the algorithm specification for use with CMS also for use with CMP.\r\n\r\n    KemOtherInfo ::= SEQUENCE {\r\n      staticString      PKIFreeText,\r\n      transactionID     OCTET STRING,\r\n      ct                OCTET STRING\r\n    }\r\n\r\nQuestions:\r\n- Should ct be OPTIONAL or not?\r\n- What about the public kem key?\r\n- Is any other content needed?\r\n- For symmetry with cms-kemri, should we rename ct to ukm? ",
      "createdAt": "2024-01-19T16:03:48Z",
      "updatedAt": "2024-02-26T15:41:43Z",
      "closedAt": "2024-02-26T15:41:43Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We decided to change to \r\n\r\n    KemOtherInfo ::= SEQUENCE {\r\n      staticString      PKIFreeText,\r\n      transactionID     OCTET STRING,\r\n      kemContext    [0] OCTET STRING OPTIONAL\r\n    }\r\n\r\nand \r\n\r\n  kemContext MAY contain additional algorithm specific context information.\r\n\r\nand further wait for cms-kemri",
          "createdAt": "2024-01-22T17:47:10Z",
          "updatedAt": "2024-01-22T17:47:10Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we cannot expect the the content of kemContext is implicit, I also added kemContect to KemCiphertextInfo.\r\n~~~~\r\n  KemCiphertextInfo ::= SEQUENCE {\r\n    kem              AlgorithmIdentifier{KEM-ALGORITHM, {...}},\r\n    ct               OCTET STRING,\r\n    kemContext   [0] OCTET STRING OPTIONAL\r\n  }\r\n~~~~\r\nThis is in line with cms-kemri where KEMRecipientInfo also transfers ukm.",
          "createdAt": "2024-02-26T07:30:31Z",
          "updatedAt": "2024-02-26T07:30:31Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alignment meeting 26.02.24\r\nI will move the kemContext from the KemCiphertextInfo to the KemBMParameters structure",
          "createdAt": "2024-02-26T15:41:43Z",
          "updatedAt": "2024-02-26T15:41:43Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOInbtzM58n9Gm",
      "title": "Replace the ASN.1 version 1988 module from Appendix F with the 2002 version module",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/40",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Should we remove the ASN.1 version 1988 module completely from the document and replace it with the version 2002 module in Appendix F?\r\nThen there is no complete ASN.1 version 1988 module available containing the KEM support.",
      "createdAt": "2024-01-19T16:07:14Z",
      "updatedAt": "2024-02-26T15:49:27Z",
      "closedAt": "2024-02-26T15:49:27Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@johngray-dev will have a look into",
          "createdAt": "2024-01-22T17:46:04Z",
          "updatedAt": "2024-01-22T17:46:04Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think we should replace the 1988 module and replace with 2002.   I also noticed our ASN.1 module has a typo in it:\r\n\r\n  cmp2012(3) },\r\n\r\nIt says cmp2012 instead of cmp2021(3).",
          "createdAt": "2024-02-24T20:54:19Z",
          "updatedAt": "2024-02-24T20:54:19Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I fixed the typo...     Will look at how easy it will be to rip out the 1988 module.",
          "createdAt": "2024-02-24T21:00:23Z",
          "updatedAt": "2024-02-24T21:00:23Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Yes, I think we should replace the 1988 module and replace with 2002. I also noticed our ASN.1 module has a typo in it:\r\n> \r\n> cmp2012(3) },\r\n> \r\n> It says cmp2012 instead of cmp2021(3).\r\n\r\nThank you for spotting this. \r\nSadly, this typo is also present in RFC9480 Appendix A.2. In Appendix A.1 it is correct.",
          "createdAt": "2024-02-26T07:26:51Z",
          "updatedAt": "2024-02-26T07:26:51Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "summary of meeting 26.02.2024:\r\n@johngray-dev will report the errata\r\nWe decided to drop the 1988 syntax ASN.1 module.",
          "createdAt": "2024-02-26T15:49:27Z",
          "updatedAt": "2024-02-26T15:49:27Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOInbtzM581lNB",
      "title": "Profile use of EnvelopedData in Section 5.2.2",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/41",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Check if we need specific profiling on the use of OPTIONAL field in EnvelopedData. Potentially add a paragraph on it.\r\nCheck also with CRMF and CMC on this.",
      "createdAt": "2024-01-22T17:36:03Z",
      "updatedAt": "2024-02-26T16:03:50Z",
      "closedAt": "2024-02-26T16:03:50Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@HBrock will look into CMS, CRMF, CMC and other docs to figure out what OriginatorInfo is used for.\r\n@johngray-dev will check this his code\r\n@DDvO David will check in OpenSSL",
          "createdAt": "2024-01-22T18:04:32Z",
          "updatedAt": "2024-01-22T18:04:32Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did some investigations and could not find any further profiling regarding use of originatorInfo in EnvelopedData in neither CMC nor CRMF.\r\nCMS writes \"originatorInfo optionally provides information about the originator.  It is present only if required by the key management algorithm.\" and information about the originator may only required for kari.\r\nI think, we do not need to profile the use of this field further.",
          "createdAt": "2024-01-24T13:23:53Z",
          "updatedAt": "2024-01-24T13:23:53Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "conclusion 26.02.2024:\r\nWe agree to say nothing additional regarding OPTIONAL fields",
          "createdAt": "2024-02-26T16:03:50Z",
          "updatedAt": "2024-02-26T16:03:50Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOInbtzM59TX17",
      "title": "Check for potential upstream problems due to changes in the ASN.1 module",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/42",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Michael StJohns wrote:\r\n> --> Next - for the changes to the body of the module, are there any upstream modules where such a change could be problematic or limiting? E.g. importing an enum that's been extended? (Do we have a tool for scanning for imports and doing the cross verification?\r\n\r\nCarl Wallace proposed:\r\nThe Referenced By feature of the data tracker could be useful if one wanted to pursue this. For example, https://datatracker.ietf.org/doc/rfc4210/referencedby/. This is well short of analyzing ASN.1 modules of course.",
      "createdAt": "2024-01-26T13:37:09Z",
      "updatedAt": "2024-02-26T16:23:35Z",
      "closedAt": "2024-02-26T16:23:35Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I checked all I-Ds and RFCs that normatively or informatively reference RFC 4210. \r\nNone of them have an ASN.1 module importing from a PKIXCMP-... module. \r\nI also checked what parts of RFC 4210 are referred to in the text of the document. \r\nRFC 4210 is referred to:\r\n- CMP as general example of a protocol managing certificates\r\n- root CA cert update\r\n- certificate request messages\r\n- delivery of centrally generated keys\r\n- POP methods other than self-signature\r\n- requesting certificates other than X.509v3 public-key certificates\r\n- revocation of certificates\r\n- transferal of PKIMessages\r\n- PKIStatus bits\r\n\r\nSee the attached PDF for details.\r\n[References to RFC4210.pdf](https://github.com/lamps-wg/cmp-updates/files/14223361/References.to.RFC4210.pdf)\r\n\r\n",
          "createdAt": "2024-02-09T15:23:17Z",
          "updatedAt": "2024-02-09T15:31:51Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "conclusion 26.02.2024\r\nThe ASN.1 module is versioned\r\nWe could not spot any ASN.1 module importing from any of the CMP modules",
          "createdAt": "2024-02-26T16:23:35Z",
          "updatedAt": "2024-02-26T16:23:35Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOInbtzM59VGhw",
      "title": "Removing normative language from Section 4.2.2",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/43",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As @primetomas proposed:\r\n1.\tSection 4.2.2.1 describes it as mandatory that the CA can send a CMP message to the end entity directly. I think this is an extremely rare case, and very hard to interpret. CAs can virtually never make an on-line connection to end entities, so this scheme assumes an out-of-band deliver of the CMP message, which is hard to envision imho. At least without stating that this is outside of the scop. The most basic cases I know of always involve some RA that initiates the request to the CA. This is confusing to me.\r\n\r\n[HB]  I fully support your point. As you know, RFC 9483 also addresses PKI Management Operations between RA and CA.\r\nBut as I read Section 4.2.2 the only mandators scheme is specified in Section 4.2.2.2. The Centralizes Scheme specified in Section 4.2.2.1 is optional. But I can envision this scheme for example in a factory with a local CA providing key generation and certificate issuance on behalf of the device. But you are perfectly right, this is not a scenario CMP would be used for.\r\nI see Section 4.2 more as a first illustration how enrollment could look like. As there is the profile for enrollment of person-certificate in the Appendix and the profile for machine-to-machine enrollment in RFC 9483, it would be fine removing normative language from Section 4.2 completely, if the WG agrees.",
      "createdAt": "2024-01-26T18:20:17Z",
      "updatedAt": "2024-06-26T06:29:20Z",
      "closedAt": "2024-06-26T06:29:20Z",
      "comments": [
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "I support removing the normative language in 4.2.2. This can be handled in profiles, and is in many cases already. I.e. 3GPP 33.310, Lightweight CMP profile, Unisig ERTMS, etc.",
          "createdAt": "2024-02-26T20:25:38Z",
          "updatedAt": "2024-02-26T20:25:38Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@johngray-dev @ounsworth @DDvO What do you think of removing normative text from [Section 4.2.2](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-mandatory-schemes) and leave this to the respective profiles?",
          "createdAt": "2024-02-27T16:12:40Z",
          "updatedAt": "2024-02-27T16:12:40Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes I agree.   Our end-entities can connect to our CA, but it is always end-entity driven.   The keys are generated at either the CA, the client or 3rd party.   I agree the text only says 4.2.2.2 is mandatory, but I see how it can be confusing since it is all under 4.2.2 titled \"Mandatory Schemes\".   Maybe just changing the title of 4.2.2 to \"Registration / Certification Schemes\", take out the normative language, then then add the MUST in 4.2.2.2 directly would make it more clear.    ",
          "createdAt": "2024-03-01T04:34:12Z",
          "updatedAt": "2024-03-01T04:34:12Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As there are several profiles of CMP available, like\r\n\r\n- Appendix D and E of RFC 4210,\r\n- RFC 9483,\r\n- 3GPP TS 33.310, and\r\n- UNISIG Subset 137.\r\n\r\nTherefore, RFC 4210 developed more to a framework and a generic protocol specification. \r\nRFC 5280 also defines the X.509 certificate and CRL content and path validation mechanism in a generic manner, and there are many protocol specific profiles available.\r\n\r\nWhen looking at RFC 4210 there are more section using normative language that may hinder claiming compliance when using one of the above listed profiles or when using CMP with a proprietary profile. \r\nIf we support the development of rfc4210bis to such a generic certificate management protocol framework, I feel like, we must also also look at other sections, e.g., Section 6, and reconsider the usage of normative language there.\r\nCurrently this was out-of-scope of the tasks we got from the LAMPS WG.",
          "createdAt": "2024-03-01T10:21:47Z",
          "updatedAt": "2024-03-01T10:21:47Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> I agree the text only says 4.2.2.2 is mandatory, but I see how it can be confusing since it is all under 4.2.2 titled \"Mandatory Schemes\". Maybe just changing the title of 4.2.2 to \"Registration / Certification Schemes\", take out the normative language, then then add the MUST in 4.2.2.2 directly would make it more clear.\r\n\r\nI support this and am confident that the WG will be fine with this.\r\nIt is essentially just an editorial change that prevents needless confusion.",
          "createdAt": "2024-03-07T12:41:40Z",
          "updatedAt": "2024-03-07T12:41:40Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The following slide was presented at IETF 119:\r\n\r\nRemove normative language from Section 4.2.2, by Tomas Gustavsson\r\n\r\nThere are various profiles that specify initial registration and certification in much more detail, e.g., Appendix C and D, RFC 9483, 3GPP TS 33.310, UNISIG Subset 137. Therefore, today rfc4210bis is more of a framework and Section 4.2 is more a guidance.\r\n\r\n**Option 1**: Adapt headline of Section 4.2.2 to avoid confusion and keep text as of RFC 4210 retaining backward compatibility.\r\n**Option 2**: Adapt headline of Section 4.2.2 to avoid confusion and remove normative language.\r\n**Option 3**: Rework Section 3, 4, and 6 to modernize it and remove normative where not needed.",
          "createdAt": "2024-03-20T13:21:21Z",
          "updatedAt": "2024-03-20T13:21:21Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With V10 the following changes were addresses:\r\n   *  Implemented some minor editorial changes modernizing the text in\r\n      Section 3, 4, and 5.2.8 as proposed during IETF 119, without\r\n      changing normative language.\r\n   *  Added to Section 4.2.2 two ToDos for further discussion, based on\r\n      the comment from Tomas Gustavsson as presented during IETF 119.\r\n\r\nI will address proposals for the remaining ToDos on the LAMPS list.",
          "createdAt": "2024-05-06T11:20:59Z",
          "updatedAt": "2024-05-06T11:20:59Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOInbtzM59VHFC",
      "title": "Add description on raVerified to Section 5.2.8",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/44",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As @primetomas proposed:\r\nAdditional: In section 4.3 I think it's good to explicitly call out raVerified POP in a subsection. It is quite commonly used.\r\nIt is mentioned in 5.1.1.3 and 5.2.8.4 and deserves a description under 4.3 imho.\r\n\r\n[HB] You are right, the raVerified POP method is only described briefly in Section 5.2.8.4. This text may be extended.\r\nSection 4.3 is describing which POP methods to uses for which key-types. Section 5.2.8 describes different POP structures and methods and is the more appropriate place describing raVerified. Currently an additional subsection for raVerified would not fit well into the existing structure of Section 5.2.8. But if we decide to restructure the section, it could nicely fit. To be honest, the current structure is a bit odd anyhow, but as it originates from RFC 2510, I tried to change as little as possible. \r\nA new structure could look like this:\r\n5.2.8.  Proof-of-Possession Structures\r\n  5.2.8.1 raVerified\r\n  5.2.8.2 POPOSigningKey Structure\r\n  5.2.8.3 POPOPrivKey Structure\r\n     5.2.8.3.1.  Inclusion of the Private Key\r\n     5.2.8.3.2.  Encrypted Certificate - Indirect Method\r\n     5.2.8.3.3.  Challenge-Response Protocol \u2013 Direct Method\r\n  5.2.8.4.  Summary of PoP Options\r\n",
      "createdAt": "2024-01-26T18:21:21Z",
      "updatedAt": "2024-02-28T15:20:37Z",
      "closedAt": "2024-02-28T15:20:37Z",
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just for comparison, the current section has this structure:\r\n\r\n>5.2.8.  Proof-of-Possession Structures\r\n5.2.8.1.  Inclusion of the Private Key\r\n5.2.8.2.  Indirect Method - Encrypted Certificate\r\n5.2.8.3.  Direct Method - Challenge-Response Protocol\r\n5.2.8.4.  Summary of PoP Options\r\n\r\nSo you are instead laying out the sections based on ASN.1 structures, and putting protocol flows as a sub-level.\r\n\r\nI think that works.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2024-02-26T14:47:20Z",
          "updatedAt": "2024-02-26T14:47:20Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "I like that",
          "createdAt": "2024-02-26T14:50:03Z",
          "updatedAt": "2024-02-26T14:50:03Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "conclusion 26.02.2024\r\nThe following points should be covered in the explanatory paragraph:\r\n- The RA MUST check the POP before using raVerified\r\n- If the RA performs changes to the original request that breaks the POP provided by the EE\r\n- If the RA request on behalf of an EE which provided the POP out-of-band\r\n- In other cases the RA MAY use raVerified together with providing the original message containing the POP in generalInfo, otherwise it SHOULD NOT use raVerified",
          "createdAt": "2024-02-26T17:21:14Z",
          "updatedAt": "2024-02-26T17:21:14Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@primetomas @johngray-dev @ounsworth  What do you think about this text explaining the usage of raVerified?\r\n\r\nSection 5.2.8.1 raVerified\r\nWhen using raVerified, the RA MUST check the proof-of-possession provided by the EE. It MAY use raVerified together with providing the original message containing the POP provided by the EE in the generalInfo field using the id-it-origPKIMessage, see Section 5.1.1.3.\r\nIf the RA performs changes to a certification request received from an EE, where these changes break the POP provided by the EE, or if the RA requests a certificate on behalf of an EE which provided the POP out-of-band, the RA MUST use the raVerified choice. Otherwise, it SHOULD NOT use raVerified.\r\n",
          "createdAt": "2024-02-27T14:21:38Z",
          "updatedAt": "2024-02-27T14:21:38Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "As long as that description also work for i.e. RA generated smart cards. I guess you can interpret that as \"the RA requests a certificate on behalf of an EE which provided the POP out-of-band\", if you interpret the EE's PoP as the smart card printer being local :-)",
          "createdAt": "2024-02-27T15:25:32Z",
          "updatedAt": "2024-02-27T15:25:32Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point.\r\nI would regard smart card production as 'on-behalf' where either the RA can provide a POP as it has access to the private key (either as it generates the key pair outside the smart card, or because it could make use of the private key on the smart card), or the POP is provided out-of-band due to organizational measures (as you suggested).\r\nOnly in the latter case usage of raVerified is needed. ",
          "createdAt": "2024-02-27T16:18:07Z",
          "updatedAt": "2024-02-27T16:18:07Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@primetomas David and I rephrased the section to address your point. What do you think?\r\n\r\n### 5.2.8.1. raVerified\r\nAn EE MUST NOT use raVerified. If an RA performs changes to a certification request breaking the provided proof-of-possession (POP), or if the RA requests a certificate on behalf of an EE and cannot provide the POP itself, the RA MUST use raVerified. Otherwise, it SHOULD NOT use raVerified.\r\nWhen introducing raVerified, the RA MUST check the existing POP, or it MUST ensure by other means that the EE is the holder of the private key. The RA MAY provide the original message containing the POP in the generalInfo field using the id-it-origPKIMessage, see Section 5.1.1.3, enabling the CA to verify it.",
          "createdAt": "2024-02-28T15:14:47Z",
          "updatedAt": "2024-02-28T15:14:47Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Sounds good!",
          "createdAt": "2024-02-28T15:16:09Z",
          "updatedAt": "2024-02-28T15:16:09Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOInbtzM59VIyh",
      "title": "Update Sections 4.4 and 5.2.5 moving outdated text to an appendix",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/45",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@primetomas proposed:\r\n2.\tSection 4.4 on root CA key update seems very verbose.\r\nIt discusses the odd case of CA rollback to great lengths, which I'm sure is extremely rare.\r\nWe discussed during the period of RFC9480, about the need for OldWithNew, which is why RFC9480 have both NewWithOld and OldWithNew as optional in 5.3.19.15. I don't think it is good to bring that back here in the form of: \"Thus, when a CA updates its key pair it must generate two extra cACertificate attribute values if certificates are made available using an X.500 directory (for a total of four: OldWithOld, OldWithNew, NewWithOld, and NewWithNew).\".\r\nUsing an x.500 directory as reference I don't think is a good one.\r\n\u2022\tKeeping these optional enables us to cut down on the verbose wording quite some. You can basically remove the whole section 4.4.1, or shorten it substantially.\r\n\u2022\tIt would be good if section 4.4 gave more advice on the standard use case of CA Renewal\r\n\u2022\tSection 4.4.2.x seems to assume an LDAP directory. Also nothing that is common, I don't think the CMP draft should specify which LDAP attributes to look up (\"Look up the cACertificate attribute in the repository\"). Either CMP have a mechanism to distribute new certificates, or it's out of scop and we can remove those words.\r\n\u2022\tThe section assumes support for X.509 v1, without extensions. I don't think this is appropriate. CMPv3 makes extensive use of extensions in the specification so assuming X.509v3 with extensions I think would be better. CMPv3 will not work without extensions anyhow.\r\n\r\n[HB] I absolutely support your point. I see Section 4.4 more as a historic and explanatory section. I cannot say, if it has any relevance today. But I know that at least Section 4.1.3 of RFC 7030 is referring to the CA rollover model of CMP pointing to Section 4.4 of RFC 4210. Therefore, I was hesitating to change anything further on this section.\r\nFinally, this section does not use normative language (except twice where it is not critical). Therefore, I do not see the need for implementing this as specified here for RFC compliance.\r\nBut as said, I am open for proposals how to update the section to express the issues you described. Maybe we can also move historic text of this section to an Appendix if people do not want to drop it completely.\r\nCould you contribute text for an updates Section 4.4? \r\n\r\n@primetomas proposed:\r\n4.\tSection 5.2.5 should be removed imho. It says it is out of scope, why define ASN.1 data structures for something that is out of scope of the document? I think it's right to keep it out of scope, but then the whole section can be removed.\r\n\r\n[HB] I do not know, why this section and the ASN.1 definition were added to the document, but they were already part of RFC 2510  :-)\r\nI could imagine moving this section together with parts of Section 4.4 to an appendix. Could you address this in your proposal for an updated Section 4.4 as well?",
      "createdAt": "2024-01-26T18:24:37Z",
      "updatedAt": "2024-03-18T14:15:26Z",
      "closedAt": "2024-03-18T14:15:25Z",
      "comments": [
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Created PR with proposed changes",
          "createdAt": "2024-02-26T21:07:25Z",
          "updatedAt": "2024-02-26T21:09:19Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your proposal. \r\nI saw, you that you updated Section 4.4 and Section 4.4.1 and removed Section 4.4.2. Section 5.2.5 is unchanged. See the diff [Section 4.4 old.diff.html.pdf](https://github.com/lamps-wg/cmp-updates/files/14422485/Section.4.4.old.diff.html.pdf).\r\n\r\nWhen checking https://datatracker.ietf.org/doc/rfc4210/referencedby/, I identified the following documents referring to Section 4.4 of RFC 4210:\r\n- draft-ietf-anima-constrained-voucher\r\n- RFC 8994\r\n- RFC 8649\r\n- RFC 7030\r\n- RFC 6024\r\n- RFC 5280\r\nTherefore, I am uncertain if we should change/delete this much text.\r\n\r\n@johngray-dev @ounsworth Do you have any further thoughts or proposals?",
          "createdAt": "2024-02-27T16:08:23Z",
          "updatedAt": "2024-02-27T16:08:23Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Should we keep the section but state that it changed and moved to Appendix?",
          "createdAt": "2024-02-27T16:33:11Z",
          "updatedAt": "2024-02-27T16:33:11Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would propose to present the proposal to the LAMPS WG during next IETF and ask for their guidance.",
          "createdAt": "2024-02-27T16:38:48Z",
          "updatedAt": "2024-02-27T16:38:48Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "The text as it is in there makes perfect sense to me, and essentially describes how our CA works for doing its CA key updates (for probably the past 20+ years).  \r\n\r\nCurrent Text:\r\nThe basis of the procedure described here is that the CA protects its\r\nnew public key using its previous private key and vice versa.  Thus,\r\nwhen a CA updates its key pair it must generate two extra\r\ncACertificate attribute values if certificates are made available\r\nusing an X.500 directory (for a total of four: OldWithOld,\r\nOldWithNew, NewWithOld, and NewWithNew).\r\n\r\nProposed Change:\r\nRFC4210 describes extra certificates used by a CA to protect its\r\nnew public key. This method has been shown to be very use case specific \r\nand no assumptions are done on this aspect and RootCaKeyUpdateContent is \r\nupdated to specify the extra fields as optional. \r\n\r\nI don't know what is meant by \"This method has been shown to be very use case specific\"?   How has it been shown to be use-case specific?   The existing text essentially explains an example of how root CA certificate management works.   I guess it is only giving one specific way of doing a CA key update but it is the use case I believe makes the most sense.  If you don't make link certificates then existing clients will have to have their trust stores manually updated with the new CA root, or some alternate out of band means for them to retrieve and trust the new root would be required.  The link certificates allow them to temporarily verify there is a link of trust between the original trusted root and the new root, and therefore trust the updated root.   I guess not everyone needs to use link certificates, but then CA updates are just so much more painful.\r\n\r\nSo if these CA key management methods aren't written in another RFC, then I think having it is in the scope of this document, it is CMP, and managing a CA's Certificate management is in scope right?   If we want to cover other use cases like the non-link cert method, or various out-of-band methods then I would be okay with moving this to an appendix, and at least keep this link cert method and why its useful, and the non-link cert method and its requirement of out-of-band updates (which we can say it out of scope).   Then at least the information is captured.\r\n\r\nSo yes, probably this needs to be mentioned in a LAMPS update",
          "createdAt": "2024-03-01T05:01:52Z",
          "updatedAt": "2024-03-01T05:01:52Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Thanks for sharing your experience.\r\n\r\n1. What I meant with \"This method has been shown to be very use case specific\" is that there are other standards (some using CMP) that performs CA updates in different ways.Two specific examples: \r\n- Link certificates using NewWithOld is common, in ICAO 9303 it is mandated. ICAO 9303 does not use NewWithOld however.\r\n- 3GPP 33.310 relies on CMP, but don't specify use of link certificates at all, and implementation I'm aware of don't use it.\r\nI do agree that link certificates as used in ICAO 9303 is useful for trust anchor update.\r\n\r\n2. Most CAs do not use X.500 directories. It doesn't feel right that RFC4210bit mentions specific database technology.\r\n\r\nWhile you can read 4.4 as it is only a discussion of an example method. This is not fully clear. Being under section 4 that is called \"Assumptions and Restrictions\".\r\n\r\nThe fact that the link certificates are now Optional in CMPv3 makes me want to update this section, because the 4.4 discussion is not written with this optionality in mind.\r\n\r\nAbout references (thanks for digging them up Hendrik):\r\n- RFC7030 references it as a defined SHOULD requirement, but no client has asked us about link certificates in EST yet. Being a SHOULD and the optionality in CMPv3 I'd expect different use case can arise. An updated section 4.4 could be helpful\r\n- RFC8994 references it much more loosely than RFC7030. An updated section 4.4 incorporating the CMPv3 optionality would suffice to fulfill this reference.\r\n- I can't find the reference in RFC5280.\r\n- RFC8649 has it under Operational Considerations, so an updated section 4.4. should work there as well\r\n- RFC6024 doesn't reference section 4.4 directly but RFC4210 in general so it's ok.\r\n- draft-ietf-anima-constrained-voucher references it as a \"mechanism described in RFC4210 Section 4.4\" being a bit problematic, but could likely be ok with an updated section 4.4?\r\n\r\nThis discussion makes me want to keep it as section 4.4, but update it to\r\n- introduce the Optionality of CMPv3\r\n- remove specification of an X.500 directory (the specs referencing this section all specify distribution through their protocol instead of through a directory)\r\n- Add something more about assumptions and restrictions. For example that CA subject DN change it a common, that old and new CAs may be on different systems, and that different use cases for the same protocol may have different restrictions and capabilities.\r\n- remove the assumption on X.509v1 only certs\r\n- potentially shorten it a bit, it's a quite long discussion section?\r\n\r\nCould you agree with that approach?\r\n",
          "createdAt": "2024-03-01T08:57:32Z",
          "updatedAt": "2024-03-01T08:57:32Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks for the lively discussion. \r\nI do not have the experience that you have regarding the variety of PKI usages. I only have my limited scope on the OT space. Therefor I may be a bit shy to change some of the old and mature text in 4210. I do not want to accidently break anything.\r\n\r\n`The fact that the link certificates are now Optional in CMPv3 makes me want to update this section, because the 4.4 discussion is not written with this optionality in mind.`\r\n[Section 5.3.19.15](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.19.15) offers a ASN.1 type with optional newWithOld and oldWithNew. This is to support also those entities that may not need the one or the other link certificate. this section says nothing about whether or not a CA should issue it for proper trust establishment in both directions.\r\n\r\n`I can't find the reference in RFC5280.`\r\nRFC5280 refers to RFC 4210 in the Security Considerations saying:\r\n   Detailed procedures for \"CA\r\n   key update\" are specified in [RFC4210], where the CA protects its new\r\n   public key using its previous private key and vice versa using two\r\n   self-issued certificates.\r\n\r\n`RFC6024 doesn't reference section 4.4 directly but RFC4210 in general so it's ok.`\r\nRFC 6042 refers to RFC 4210 with regard to in-band trust anchor update saying:\r\n   Routine trust\r\n   anchor rekey operations typically require similar out-of-band checks,\r\n   though in-band rekey of a trust anchor is supported by the\r\n   Certificate Management Protocol (CMP) [RFC4210].\r\n\r\nGenerally speaking, I also think, theses references should not hinder updating Section 4.4. I also like Tomas proposals. Maybe we can leave LDAP as an example.\r\nAs said before, I just do not fee comfortable with changing the content of this section due to my limited background on this section and therefore would need strong support by the LAMPS WG or others having this background.",
          "createdAt": "2024-03-01T10:09:21Z",
          "updatedAt": "2024-03-01T10:09:21Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "closed after merging PR #54",
          "createdAt": "2024-03-18T14:15:26Z",
          "updatedAt": "2024-03-18T14:15:26Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOInbtzM5-jWwF",
      "title": "Context input to KDF",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/46",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft of cms-kemri specified ukm as a field in KEMRecipientInfo. I must be used in CMSORIforKEMOtherInfo as input for the KDF.\r\nSection 3 of cms-kemri writes:\r\n\"ukm is optional user keying material. When the ukm value is provided, it is used as part of the info structure described in Section 5 to provide a context input to the key-derivation function. For example, the ukm value could include a nonce, application-specific context information, or an identifier for the originator. A KEM algorithm may place requirements on the ukm value. Implementations that do not support the ukm field SHOULD gracefully discontinue processing when the ukm field is present. Note that this requirement expands the original purpose of the ukm described in Section 10.2.6 of [RFC5652]; it is not limited to being used with key agreement algorithms.\"\r\n\r\nCurrently we specify KemOtherInfo as CMP alternative to ukm. It contains a static string \"CMP-KEM\", the transactionID and an optional kemContext. The kemContext is supposed to contain additional algorithm specific context information.\r\n- I think we need to describe the use of KemOtherInfo and kemContext more specific, as for ukm above.\r\n- Do we also need to offer the transferring the kemContext as part of the delivering the kemct, potentially as part of KemCiphertextInfo structure?\r\n\r\n@johngray-dev @ounsworth What do think?",
      "createdAt": "2024-02-07T14:45:01Z",
      "updatedAt": "2024-02-26T16:25:53Z",
      "closedAt": "2024-02-26T16:25:53Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Additionally, the CMSORIforKEMOtherInfo also contains the algorithm the derived key will be used for as well as its keylength.\r\nI think we discussed this before and we decided that the sender of the kemct should not decide on this, but it should leave this to the holder of the kem private key.\r\nThis just to make sure, that we think it is safe to stick to this approach. ",
          "createdAt": "2024-02-07T15:07:30Z",
          "updatedAt": "2024-02-07T15:07:30Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "while discussing with Kiron, I decided to add kemContext also to the KemCiphertextInfo structure to be in line with the definition in cms-kemri.\r\n\r\n@johngray-dev @ounsworth What do you think?",
          "createdAt": "2024-02-19T17:47:30Z",
          "updatedAt": "2024-02-19T17:47:30Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "conclusion 26.02.2024\r\nsee #39 ",
          "createdAt": "2024-02-26T16:25:53Z",
          "updatedAt": "2024-02-26T16:25:53Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOInbtzM6AIrHm",
      "title": "Clear up incompatibility issue in section 5.1.3.1",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/48",
      "state": "CLOSED",
      "author": "johngray-dev",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In RFC 5.1.3.1 it contains a description of Key expansion that should occur when the Key is larger than the one-way function:\r\n\r\n In the above protectionAlg, the salt value is appended to the shared\r\n   secret input.  The OWF is then applied iterationCount times, where\r\n   the salted secret is the input to the first iteration and, for each\r\n   successive iteration, the input is set to be the output of the\r\n   previous iteration.  The output of the final iteration (called\r\n   \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used\r\n   to form the symmetric key.  If the MAC algorithm requires a K-bit key\r\n   and K <= H, then the most significant K bits of BASEKEY are used.  If\r\n   K > H, then all of BASEKEY is used for the most significant H bits of\r\n   the key, OWF(\"1\" || BASEKEY) is used for the next most significant H\r\n   bits of the key, OWF(\"2\" || BASEKEY) is used for the next most\r\n   significant H bits of the key, and so on, until all K bits have been\r\n   derived.  [Here \"N\" is the ASCII byte encoding the number N and \"||\"\r\n   represents concatenation.]\r\n\r\nFrom David:\r\nI just came across the weird situation that the definition of PBM in RFC 4210 section 5.1.3.1 describes\r\n- for the case that the base key, derived using the one-way-function, is too short for the HMAC key input -\r\na different (and needlessly complicated) padding than the one that was specified in RFC 4211 section 4.4,\r\nwhich uses a simple zero padding defined in RFC 2104 section 2.\r\n\r\nAre you aware of this inconsistency, which can lead to incompatibility of implementations\r\nin case the size of the hash alg used as the OWF is smaller than of the hash alg used for the HMAC?\r\nLooks like most implementations follow RFC 4211 here. What does your implementation do?\r\n\r\n",
      "createdAt": "2024-02-22T19:06:46Z",
      "updatedAt": "2024-03-18T14:05:56Z",
      "closedAt": "2024-03-18T14:05:56Z",
      "comments": [
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, we have definitely noticed this situation.  We had incorrectly implemented the key expansion in 4210 in our own proprietary version (we call this \u201centrust-style\u201d), and recently corrected it to also support the RFC 4210 key expansion (we call it \u201crfc4210-style\u201d).   So I take it you have implemented the 4211 way, which is different that what we did, and therefore we would probably not be compatible with something like a 3DES SHA1 MAC, or AES SHA1 or any combination where the key used is larger than the OWF.\r\n\r\n I would hope one possible mitigation is that *most* implementations would have moved on to using a SHA2 based OWF in which case they should be good in almost all cases.   \r\n\r\nWe had a bunch of internal discussions on this today, and it seems less horrible than I first thought\u2026 \r\n\r\nRFC 4211 seems to only talk about HMAC, and in these cases key expansion is never needed.   The OWF will run first to derive K before being put into the Mac function and the HMac will internally digest if needed, so essentially no external expansion is needed.   RFC 4210 talks about key expansion when K > H, and it is not required when K <= H\r\n\r\nSo, in this regard, 4211 and 4210 will not lead to an incompatibility.   If you need to use (for example) an AES MAC algorithm and key expansion is required, you would follow RFC 4210, if you don\u2019t need key expansion you can follow 4211 and/or 4210.    \r\n\r\nIt is just very unclear and totally confusing, so I still think we want a clarifying sentence or two in RFC 4210-bis.\r\n\r\n\r\nWe could state something like:\r\n\r\n\"RFC 4210 section 5.1.3.1 gives a method of key expansion to be used when the key used for a Mac algorithm is larger than the size of the one-way-function.   RFC 4211 section 4.4 did not mention this key expansion method and gives an example using HMAC algorithms where key expansion is not needed.   It is recognized that this omission in RFC 4211 can lead to confusion and possible incompatibility if RFC 4210 key expansion is not used when needed.  Therefore, when key expansion is required (when K > H) the key expansion defined in RFC 4210 section 5.1.3.1 MUST be used.\"\r\n \r\n\r\n\r\n\r\n",
          "createdAt": "2024-02-22T19:10:12Z",
          "updatedAt": "2024-02-22T21:49:34Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I just noticed in RFC 4211 in section 4.4 says:  \r\n\r\nAll implementations MUST\r\n      support SHA-1.\r\n\r\nSo I don't know if adding the suggested text above becomes problematic.   Ideally people wouldn't use SHA1 anymore, but I suppose if they do then we would be recommending they use a key the same size as SHA1 (which I guess would be HMAC SHA1 or AES128 SHA1 or combinations like that for compatibility.",
          "createdAt": "2024-02-22T19:17:28Z",
          "updatedAt": "2024-02-22T19:17:28Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@johngray-dev, thank you for the explanation.\r\n\r\nWhile writing CMP Algorithms we came across the requirement of CRMF implementing SHA-1. Russ wrote [RFC 9045](https://datatracker.ietf.org/doc/html/rfc9045) updating these requirements.\r\nRFC9045 states: MUST implement id-PasswordBasedMAC and MAY implement PBMAC1\r\nFor PasswordBasedMAC: MUST implement SHA-256 for owf and MUST implement HMAC-SHA256 and SHOULD implement AES-GMAC for mac\r\n\r\nIn [RFC 9481](https://datatracker.ietf.org/doc/html/rfc9481) we list SHA2 and SHAKE as potential owf in Section 2 and SHA2-based HMAC, AES-GMAC, and SHAKE-based KMAC as potential mac in Section 6.2. Section 7.1 of RFC 9481 requires SHA-256 and HMAC-SHA256  to be used with PasswordBasedMAC.\r\n\r\nWhat does this change about the requirement for key expansion?",
          "createdAt": "2024-02-23T08:12:58Z",
          "updatedAt": "2024-02-23T08:12:58Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As addition to rfc4210bis Section 5.1.3.1 we could write the following based on John's proposal:\r\n\r\ncurrent text:\r\n\"5.1.3.1.  Shared Secret Information\r\n\r\nIn this case, the sender and recipient share secret information with sufficient entropy (established via out-of-band means). PKIProtection will contain a MAC value and the protectionAlg MAY be one of the options described in CMP Algorithms Section 6.1 [RFC9481].\r\n\r\nThe following text gives further details on PasswordBasedMac. It is mentioned in Section 6.1.1 of [RFC9481] for backward compatibility. More modern alternatives are listed in Section 6.1 of [RFC9481].\r\n~~~~\r\n  id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\r\n  PBMParameter ::= SEQUENCE {\r\n     salt                OCTET STRING,\r\n     owf                 AlgorithmIdentifier,\r\n     iterationCount      INTEGER,\r\n     mac                 AlgorithmIdentifier\r\n  }\r\n~~~~\r\nIn the above protectionAlg, the salt value is appended to the shared secret input. The OWF is then applied iterationCount times, where the salted secret is the input to the first iteration and, for each successive iteration, the input is set to be the output of the previous iteration. The output of the final iteration (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]\r\n\r\nNote: It is RECOMMENDED that the fields of PBMParameter remain constant throughout the messages of a single transaction (e.g., ir/ip/certConf/pkiConf) to reduce the overhead associated with PasswordBasedMac computation.\"\r\n\r\nnew text:\r\n\r\n\"5.1.3.1.  Shared Secret Information\r\n\r\nIn this case, the sender and recipient share secret information with sufficient entropy (established via out-of-band means). PKIProtection will contain a MAC value and the protectionAlg MAY be one of the options described in CMP Algorithms Section 6.1 [RFC9481].\r\n\r\n**_The algorithm identifier id-PasswordBasedMac is defined in Section 4.4 of RFC 4211 and updated by RFC 9045._** It is mentioned in Section 6.1.1 of [RFC9481] for backward compatibility. More modern alternatives are listed in Section 6.1 of [RFC9481].\r\n~~~~\r\n  id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\r\n  PBMParameter ::= SEQUENCE {\r\n     salt                OCTET STRING,\r\n     owf                 AlgorithmIdentifier,\r\n     iterationCount      INTEGER,\r\n     mac                 AlgorithmIdentifier\r\n  }\r\n~~~~\r\n**_The following text  gives a method of key expansion to be used when the key used for a MAC-algorithm is larger than the size of the one-way-function._**\r\n\r\n**_Note: RFC 4211 Section 4.4  and RFC 9045 do not mention this key expansion method and gives an example using HMAC algorithms where key expansion is not needed. It is recognized that this omission in RFC 4211 can lead to confusion and possible incompatibility if RFC 4210 key expansion is not used when needed. Therefore, when key expansion is required (when K > H) the key expansion defined in in the following text MUST be used._**\r\n\r\nIn the above protectionAlg, the salt value is appended to the shared secret input. The OWF is then applied iterationCount times, where the salted secret is the input to the first iteration and, for each successive iteration, the input is set to be the output of the previous iteration. The output of the final iteration (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]\r\n\r\nNote: It is RECOMMENDED that the fields of PBMParameter remain constant throughout the messages of a single transaction (e.g., ir/ip/certConf/pkiConf) to reduce the overhead associated with PasswordBasedMac computation.\"",
          "createdAt": "2024-02-23T08:39:38Z",
          "updatedAt": "2024-02-23T08:39:38Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "conclusion 26.02.2024:\r\nTake the changes written above with the following changes.\r\nold:\r\n\"The following text gives a method of key expansion to be used when the key used for a MAC-algorithm is larger than the size of the one-way-function.\"\r\nnew:\r\n\"The following text gives a method of key expansion to be used when the MAC-algorithm requires an input length that is larger than the size of the one-way-function.\"",
          "createdAt": "2024-02-26T16:52:13Z",
          "updatedAt": "2024-02-26T16:52:13Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I responded to the email communication from San Francisco IETF las July on this matter asking Russ, David H. , and Mark for their opinion on \r\n- Is the text in rfc4210bis Section 5.1.3.1 sufficiently clarifying the issue? \r\n- How to proceed regarding a potential erratum to RFC 4211 or even RFC 9045?\r\n\r\n\r\n~~~~\r\nRuss, David H., Mark\r\n\r\nI am uncertain if there was final agreement on how to handle this issue back last summer. I did not see further\r\ncommunication on this topic and no errata on RFC 4211. Maybe I missed something.\r\n\r\nIn the rfc4210bis editors group we discussed this issue again some days ago, see\r\nhttps://github.com/lamps-wg/cmp-updates/issues/48, and proposed clarifying text for rfc4210bis, see\r\nhttps://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#name-shared-secret-information. I am\r\nplanning to submit the version on github latest on Monday.\r\n\r\nThe conclusion was, as long as HMAC is used as mac with id-PasswordBasedMAC, there is no need for key expansion as\r\nHMAC has no required input length. In general, an implementation could use different MAC algorithms for messages\r\nprotection as well as for POP. \r\n\r\nRFC 9481 updates RFC 4210. In RFC 9481 we list SHA2 and SHAKE as potential owf in Section 2 and SHA2-based HMAC,\r\nAES-GMAC, and SHAKE-based KMAC as potential mac in Section 6.2. Section 7.1 of RFC 9481 requires SHA-256 and\r\nHMAC-SHA256 to be used with id-PasswordBasedMAC.\r\n\r\nRFC 9045 updates RFC 4211. RFC9045 states: MUST implement id-PasswordBasedMAC and MAY implement PBMAC1,\r\nand for id-PasswordBasedMAC: MUST implement SHA-256 for owf and MUST implement HMAC-SHA256 and SHOULD\r\nimplement AES-GMAC for mac.\r\n\r\nBoth CMP and CRMF do not restrict implementations to only using the above listed algorithms with id-PasswordBasedMAC\r\nfor message protection or POP. Therefore, I think there is still need for aligning both specifications regarding key expansion.\r\n\r\nI have two questions:\r\nIs the text in rfc4210bis Section 5.1.3.1 sufficiently clarifying the issue? \r\nHow to proceed regarding a potential erratum to RFC 4211 or even RFC 9045?\r\n\r\nHendrik\r\n~~~~",
          "createdAt": "2024-02-29T15:28:57Z",
          "updatedAt": "2024-02-29T15:28:57Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "David H. and Russ reported consent with the text proposed in rfc4210bis on email.\r\nI did not get any feedback from Mark.\r\nNo one indicated need for an errata on RFC 4211 or RFC 9045 so fare.\r\n\r\nI will wait for further feedback until after IETF and close the issue if nothing more comes.",
          "createdAt": "2024-03-06T12:39:05Z",
          "updatedAt": "2024-03-06T12:39:05Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "During LAMPS meeting today, no one raised the request to file a erratum to RFC 4211.",
          "createdAt": "2024-03-18T14:05:56Z",
          "updatedAt": "2024-03-18T14:05:56Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOInbtzM6BckG5",
      "title": "Why is CAKeyUpdAnnContent not identical to RootCaKeyUpdateContent?",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/50",
      "state": "CLOSED",
      "author": "primetomas",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "These are identical data structures for the same use case, isn't it?",
      "createdAt": "2024-03-06T15:14:24Z",
      "updatedAt": "2024-03-11T08:46:25Z",
      "closedAt": "2024-03-11T08:46:25Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "CAKeyUpdAnnContent is the content type for an announcement message from the CA/RA to the EE, see [Section 5.3.13](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.13) and [Section 5.3.19.5](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.19.5). I cannot say, why it is available as ckuann and as genm value.\r\n\r\nRootCaKeyUpdateContent was added by RFC 9480 for genm/genp message pair. The genm of type id-it-rootCaCert offers the EE a request message to request a root CA key update from the RA/CA, see [Section 5.3.19.15](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.19.15) and [RFC 9483 Section 4.3.2](https://datatracker.ietf.org/doc/html/rfc9483#section-4.3.2).\r\n\r\nIn contrast to CAKeyUpdAnnContent, in RootCaKeyUpdateContent the newWithOld and OldWithNew link certificates are optional and can be omitted, depending on the EE needs.",
          "createdAt": "2024-03-06T15:37:34Z",
          "updatedAt": "2024-03-06T15:37:34Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Typically the number of certificates contained in a message rule the size of the message. This becomes even more crucial with PQC algorithms. Therefore, we want to offer a message that does not need to transfer certificates that are not needed.\r\nWe think, in many cases the oldWithNew certificate is not required, therefore, we wanted to have it optional. For flexibility, we also defined newWithOld as optional, but RFC 9483 required to use it. So the message offers full flexibility, but the profile limits it to the main use case.",
          "createdAt": "2024-03-06T16:01:25Z",
          "updatedAt": "2024-03-06T16:01:25Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Exactly, sorry for the brief description. I know the differences. When introducing CMPv3 why not update CAKeyUpdAnnContent as well?",
          "createdAt": "2024-03-07T08:51:57Z",
          "updatedAt": "2024-03-07T08:51:57Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right, we could have changed CAKeyUpdAnnContent, but this would have complicated the version management.\r\n\r\nThe design criteria for CMP Updates was to add what is needed for the Lightweight CMP Profile and not to break or change any existing functionality. We do not use any announcement messages in LCMPP. Therefore, we did not think about changing the content of outbound CA messages like ckuann or genm with id-it-caKeyUpdateInfo.\r\n\r\nAre you aware of products making use of announcement messages?\r\nDo you think this is a change we should add to rfc4210bis?",
          "createdAt": "2024-03-07T10:41:19Z",
          "updatedAt": "2024-03-07T10:41:19Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "I'm not aware of any product that uses ckuann or genm with id-it-caKeyUpdateInfo. So not updating will not change any use case that I'm aware of. \r\nFor future consistence (you never know who gets into which part of the spec) it would be worth changing it imho. Since I don't know of anyone using it, I also don't know that anyone would be hurt by it, and it would make the specification more consistent and easier to grasp/harder to make mistakes.",
          "createdAt": "2024-03-07T11:21:17Z",
          "updatedAt": "2024-03-07T11:21:17Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you. I see your point.\r\n\r\nIf we want to align this, I would propose to define that ckuann uses RootCaKeyUpdateContent with CMP v3 instead of changing the ASN.1 definition of CAKeyUpdAnnContent. \r\nI am uncertain how to change the ASN.1 syntax of CAKeyUpdAnnContent keeping backward compatible.\r\n\r\nWith genm the CA could technically already use id-it-caKeyUpdateInfo. This would need to be changed in Section 5.3.19.5.\r\n\r\nWhat do you think?",
          "createdAt": "2024-03-07T12:13:27Z",
          "updatedAt": "2024-03-07T12:13:27Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Yeah, we could cleanly modify ckuann to use RootCaKeyUpdateContent (instead of CAKeyUpdAnnContent) by requiring this to be indicated with CMPv3 in the message header,\r\nand deprecate CAKeyUpdAnnContent.",
          "createdAt": "2024-03-07T12:31:06Z",
          "updatedAt": "2024-03-07T12:31:06Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Agree, that sounds like a neat solution.",
          "createdAt": "2024-03-07T13:52:15Z",
          "updatedAt": "2024-03-07T13:52:15Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This will also affect [Appendix D.4](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#appendix-D.4).\r\nI would propose to also use RootCaKeyUpdateContent there and allow CAKeyUpdAnnContent only if backward compatibility is required.\r\nShould we keep the requirement of oldWithNew and newWithOld beeing both present, or should be change anything there?",
          "createdAt": "2024-03-07T14:45:09Z",
          "updatedAt": "2024-03-07T14:45:09Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "I think we should make them optional as for RootCaKeyUpdateContent. That makes CMP more adaptable to different use cases.",
          "createdAt": "2024-03-07T15:03:17Z",
          "updatedAt": "2024-03-07T15:03:17Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right, they are optional in RootCaKeyUpdateContent. The question is, shall we change the profile in Appendix D.4.\r\nMy proposal would be to at least require setting newWithOld in the profile as we also did in RFC9483 Section 4.3.2. \r\nBut as said above, I am not aware of the intended use case behind this PKI management operation. Therefore, oldWithNew may also be required.",
          "createdAt": "2024-03-07T15:14:03Z",
          "updatedAt": "2024-03-07T15:14:03Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Appendix D.4 looks very much like [5.3.19.5](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.19.15) to me. \"via some transport mechanism\" in D.4, sounds like \"for example the one described in 5.3.19.15, or another method.",
          "createdAt": "2024-03-07T15:27:18Z",
          "updatedAt": "2024-03-07T15:27:18Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point is that Section 5.3.19.15 specifies the fully flexible ASN.1 structure and Appendix D.4 is supposed to be a profile providing a clear guidance what options to use and what not.\r\nIf we now say, newWithOld and oldWithNew are optional, it a repetition of the content from before and no profiling. Therefore, I asked for the use case behind Appendix D.4 to decide on what option is needed. As we do not know the use case, we could use the profiling like in RFC 9483 saying the newWithOld is required and oldWithNew is optional.",
          "createdAt": "2024-03-07T15:47:45Z",
          "updatedAt": "2024-03-07T15:47:45Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "Imho D.4 isn't much of a profile. To me it looks like Appendix D just _must_ have a section for every message of the specification, even if it doesn't add any, or much, information. It doesn't really add any new information that is not already in [5.3.19.15](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.19.15), [5.3.13](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.13) and [5.3.19.5](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#section-5.3.19.5). Not sure what profile guidance information D.4 adds here for implementors? [Appendix D.3](https://lamps-wg.github.io/cmp-updates/draft-ietf-lamps-rfc4210bis.html#appendix-D.3) doesn't give much guidance either imho. Changing \"present\" to \"optional\" in D.4 at least makes it consistent across the document. D.4 doesn't describe any specific use case or processing, so what harm can it do?",
          "createdAt": "2024-03-07T16:01:19Z",
          "updatedAt": "2024-03-07T16:01:19Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, probably did not explain my point properly.\r\n\r\nIn CAKeyUpdAnnContent there are no options. There is no profiling possible.\r\nIf we introduce RootCaKeyUpdateContent instead, we also introduce options in the syntax.\r\nTypically a profile explains how to handle optional fields depending on the use case the profile addresses. I wanted to clarify, if the we want to state how to handle these options in the profile defined in Appendix C and D.\r\n\r\nAs we do not know what uses case drives the profile in Appendix D.4, there three potential was to go forward\r\n- both optional fields must be used (this is the status quo as of RFC 4210) \r\n- only newWithOld must be set and oldWithNew is optional (this is in line with RFC 9483)\r\n- both fields are optional (this is what you propose)",
          "createdAt": "2024-03-08T07:54:39Z",
          "updatedAt": "2024-03-08T07:54:39Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I prepared a PR implementing this change. Does that fit?\r\n\r\nWhile doing the changes, I noticed that I had to introduce a new PKIBody choice \"ckuannV3\" of type RootCaKeyUpdateContent for use with CMP V3. For backward compatibility I had to keep ckuann unchanged for use with CMP V2.",
          "createdAt": "2024-03-08T15:31:56Z",
          "updatedAt": "2024-03-08T15:31:56Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I updated the PR (2c87ff1bfda862d4182398e2d9cba3c3e4a112a9) introducing \r\n~~~\r\nCAKeyUpdContent ::= CHOICE {\r\n    cAKeyUpdAnnV2      CAKeyUpdAnnContent, -- deprecated\r\n    cAKeyUpdAnnV3  [0] RootCaKeyUpdateContent\r\n}\r\n~~~\r\nto ease backward compatibility.\r\n\r\n@primetomas,  what do you think. Is this what you had in mind?",
          "createdAt": "2024-03-11T08:05:21Z",
          "updatedAt": "2024-03-11T08:05:21Z"
        },
        {
          "author": "primetomas",
          "authorAssociation": "NONE",
          "body": "That sounds great. I can close this issue.\r\n",
          "createdAt": "2024-03-11T08:46:25Z",
          "updatedAt": "2024-03-11T08:46:25Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOInbtzM6CZ_cG",
      "title": "Check if IANA references pointing to RFC 4210 must be updated to rfc4210bis ",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/53",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "IANA wrote:\r\nShould those references be replaced with references to this document (this is typical)? For IANA\u2019s purposes, this could be covered by a line that says something like \u201cAll existing references to RFC 4210 at https://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml and https://www.iana.org/assignments/core-parameters/core-parameters.xhtml should be replaced with references to this document,\u201d or \u201cAll existing references [...] except for the following registrations:\u201d",
      "createdAt": "2024-03-15T06:59:47Z",
      "updatedAt": "2024-03-20T08:31:03Z",
      "closedAt": "2024-03-20T08:31:03Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC XXXX is new RFC number of --> the assigned numerical RFC value for I-D.ietf-lamps-rfc4210bis\r\nRFC YYYY is new RFC number of --> the assigned numerical RFC value for I-D.ietf-lamps-rfc6712bis\r\n\r\n\r\nhttps://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml\r\nSMI Security for PKIX Module Identifier\r\n- id-mod-cmp: keep RFC 2510\r\n- id-mod-cmp2000: keep RFC 4210\r\n- BTW: should RFC4211 be the reference for id-mod-crmf2005?\r\n- id-mod-cmp2000-02: keep RFC 5912\r\n- id-mod-cmp2021-88: keep RFC 9480\r\n- id-mod-cmp2021-02: keep RFC 9480\r\n\r\n\r\nSMI Security for PKIX Extended Key Purpose\r\n- id-kp-cmKGA: RFC 9480 -> RFC XXXX\r\n\r\n\r\nSMI Security for PKIX CMP Information Types\r\n- id-it-caProtEncCert: RFC 2510 -> RFC XXX\r\n- id-it-signKeyPairTypes: RFC 2510 -> RFC XXX\r\n- id-it-encKeyPairTypes: RFC 2510 -> RFC XXX\r\n- id-it-preferredSymmAlg: RFC 2510 -> RFC XXX\r\n- id-it-caKeyUpdateInfo: RFC 2510 -> RFC XXX\r\n- id-it-currentCRL: RFC 2510 -> RFC XXX\r\n- id-it-unsupportedOIDs: RFC 4210 -> RFC XXXX\r\n- id-it-keyPairParamReq: RFC 4210 -> RFC XXXX\r\n- id-it-keyPairParamRep: RFC 4210 -> RFC XXXX\r\n- id-it-revPassphrase: RFC 4210 -> RFC XXXX\r\n- id-it-implicitConfirm: RFC 4210 -> RFC XXXX\r\n- id-it-confirmWaitTime: RFC 4210 -> RFC XXXX\r\n- id-it-origPKIMessage: RFC 4210 -> RFC XXXX\r\n- id-it-suppLangTags: RFC 4210 -> RFC XXXX\r\n- id-it-caCerts: RFC 9480 -> RFC XXXX\r\n- id-it-rootCaKeyUpdate: RFC 9480 -> RFC XXXX\r\n- id-it-certReqTemplate: RFC 9480 -> RFC XXXX\r\n- id-it-rootCaCert: RFC 9480 -> RFC XXXX\r\n- id-it-certProfile: RFC 9480 -> RFC XXXX\r\n- id-it-crlStatusList: RFC 9480 -> RFC XXXX\r\n- id-it-crls: RFC 9480 -> RFC XXXX\r\n\r\n\r\nSMI Security for PKIX CRMF Registration Controls\r\n- id-regCtrl-altCertTemplate: RFC 4210 -> RFC XXXX\r\n- id-regCtrl-algId: RFC 9480 -> RFC XXXX\r\n- id-regCtrl-rsaKeyLen: RFC 9480 -> RFC XXXX\r\n\r\n\r\nhttps://www.iana.org/assignments/core-parameters/core-parameters.xhtml\r\nCoAP Content-Formats\r\n- application/pkixcmp: RFC 9482, RFC 4210 -> RFC 9482, RFC YYYY",
          "createdAt": "2024-03-18T14:33:28Z",
          "updatedAt": "2024-03-18T14:46:02Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@russhousley may I ask for your advice?\r\nIANA asked me to specify which references shall be updated to the new RFC 4210bis and 6712bis. Above I provided a list. But I am uncertain if it is correct to update also references to the RFCs, where the OIDs were originally registered.\r\nFor example I found OIDs with reference RFC 2510, even though the OID is still in use in RFC 4210. I had expected that this reference should have been updated to RFC 4210 back then.",
          "createdAt": "2024-03-18T14:46:22Z",
          "updatedAt": "2024-03-18T14:46:22Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "I did a very quick review.  This looks correct to me.",
          "createdAt": "2024-03-19T03:35:27Z",
          "updatedAt": "2024-03-19T03:35:27Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOInbtzM6CyUjC",
      "title": "Clarify if reference to ITU-T X.509 shall be updated to RFC 5280",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/55",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Russ wrote:\r\nMike:\r\n> Hmm. 4210 pre-dates 5280. I suppose there are two questions here:\r\n> \r\n> 1) can someone who was around please illuminate on why 2510/4210 references an ISO doc and not an IETF doc (2459/3280/5280)?\r\n\r\nI do not recall why RFC 2510 did not reference RFC 2459.  However, the development of the two documents was going on at the same time.  My guess is that we did not know which would reach the RFC Editor first.\r\n\r\n> 2) Is it a trivial change to swap out the X.509 reference? Or will that turn into a cascade of difference-hunting and backwards compatibility? Is that worth doing?\r\n\r\nReference to RFC 5280 seems like the right thing to do today.\r\nRuss\r\n\r\nMichael wrote:\r\nIn https://datatracker.ietf.org/doc/draft-ietf-lamps-rfc4210bis/  it says:\r\n   The term\r\n   \"certificate\" in this document refers to an X.509v3 Certificate as\r\n   defined in [ITU.X509.2000].\r\nand I wondered why an ITU document is referred to, rather than RFC5280.\r\nFurther, why the 2000 era document, when I think there is a 2019 one.\r\n{at least, the 2019 version is freely available, but I can't find the 2000\r\nera document easily}",
      "createdAt": "2024-03-19T07:26:57Z",
      "updatedAt": "2024-03-20T08:30:48Z",
      "closedAt": "2024-03-20T08:30:48Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 2510 / RFC 4210 define \u201ccertificate\u201d as defined in ITU-T X.509 in the abstract / in the introduction. \r\nOf course, the term \u201ccertificate\u201d is used on many many places.\r\n\r\nRFC 2510 and RFC 4210 use the ASN.1 types Certificate as defined in RFC 2459.\r\nRFC 4210 introduces the ASN.1 type CMPCertificate.\r\n\r\n~~~\r\n      CMPCertificate ::= CHOICE {\r\n         x509v3PKCert        Certificate\r\n      }\r\n   -- This syntax, while bits-on-the-wire compatible with the\r\n   -- standard X.509 definition of \"Certificate\", allows the\r\n   -- possibility of future certificate types [\u2026]\r\n~~~\r\n\r\nWith the 2002 ASN.1 module updates the type Certificate is imported from the 2002 ASN.1 module of RFC 5280.\r\nAs the ASN.1 module in rfc4210bis in based upon that 2002 ASN.1 module, it clearly imports from RFC 5280. Therefore, I think it is safe to change the reference from ITU-T X.509 to RFC 5280.",
          "createdAt": "2024-03-19T14:33:17Z",
          "updatedAt": "2024-03-19T14:39:40Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOInbtzM6L30me",
      "title": "Identifying private key when using EnvelopedData for indirect POPO ",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/62",
      "state": "CLOSED",
      "author": "rajeev-0",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When using EnvelopedData with encrypted certificate (section 5.2.2) for indirect POPO (section 5.2.8.3.2), RecipientIdentifier in KeyTransRecipientInfo ([RFC 5652, section 6.2.1](https://www.rfc-editor.org/rfc/rfc5652.html#section-6.2.1) ) and KEMRecipientInfo ([draft-ietf-lamps-cms-kemri-08, section 3](https://www.ietf.org/archive/id/draft-ietf-lamps-cms-kemri-08.html#section-3)) can not be used by client to identify the corresponding private key for obtaining content-encryption key (CEK). So an alternative should be provided for matching the cert response (containing EnvelopedData with encrypted certificate) to corresponding private key. \r\n\r\nOne suggestion would be to add a note in section 5.2.2 stating:\r\nWhen using certificate in encrypted form for indirect POP, client should use `transactionID` and `certReqId` to identify the corresponding private key for decrypting the content-encryption key. ",
      "createdAt": "2024-06-11T15:02:56Z",
      "updatedAt": "2024-07-12T15:00:46Z",
      "closedAt": "2024-07-12T15:00:46Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indirect POP is specifically relevant for KEM keys. I posted a question on this topic to the LAMPS email list.\r\nIn any case if Indirect POP is used, also with key agreement, the certificate is delivered in encrypted form and the recipient has no knowledge of issuerAndSerialNumber or subjectKeyIdentifier before decrypting it.\r\nTherefore, the note is specific to Indirect POP and we should consider adding it to Section 5.2.8.3.2.",
          "createdAt": "2024-06-12T07:24:59Z",
          "updatedAt": "2024-06-12T07:24:59Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An additional paragraphe to Section 5.2.8.3.2 could be:\r\n\"Note that in some cases CMS enveloped data uses `issuerAndSerialNumber` or `subjectKeyIdentifier` to specify the recipient's certificate, and thereby the recipient's public key, that was used to generate the key-encryption key.  In the indirect method, the specified recipient's certificate is delivered in encrypted form and therefore the recipient cannot use `issuerAndSerialNumber` or `subjectKeyIdentifier` to identify the private key for decrypting the key-encryption key. Alternatively the recipient should use `transactionID` and `certReqId`.\"",
          "createdAt": "2024-06-12T07:56:48Z",
          "updatedAt": "2024-06-14T08:37:11Z"
        },
        {
          "author": "rajeev-0",
          "authorAssociation": "NONE",
          "body": " I agree, it should be added to Section 5.3.8.3.2.",
          "createdAt": "2024-06-12T08:37:43Z",
          "updatedAt": "2024-06-12T08:37:43Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Russ proposed to use a key identifyer, see https://mailarchive.ietf.org/arch/msg/spasm/0xuq496AV-pkyiAF2kqvOTi0-uI/",
          "createdAt": "2024-06-14T08:34:40Z",
          "updatedAt": "2024-06-14T08:34:40Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Russ proposes to specify method 4) from RFC 7093 Section 2 (https://datatracker.ietf.org/doc/html/rfc7093#section-2) to use with SHA-256 for the CMS recipient identifier in RecipienInfo.\r\n\r\nAn additional paragraphe to Section 5.2.8.3.2 could be:\r\n\"Note that when using CMS `EnvelopedData` to deliver the newly issued certificate in encrypted form, the sender requires to let the recipient know which key was used to protect the certificate.  All `RecipientInfo` types, except `PasswordRecipientInfo`, offer two choices to specify the recipient's certificate, and thereby the recipient's public key, that was used to protect the content-encryption key.  As long as the newly issued certificate was not decrypted, the recipient cannot use any content of that certificate to identify this key.  Therefore, the sender and recipient MUST use a SHA-256 hash of the DER encoding of a `SubjectPublicKeyInfo` value in the `SubjectKeyIdentifier` choice of `RecipientIdentifier`, which uses method 4 from RFC 7093 Section 2,  to identify the key that was used by the sender to protect the content-encryption key.\"\r\n\r\n@DDvO What do you think?",
          "createdAt": "2024-06-14T14:05:28Z",
          "updatedAt": "2024-06-14T14:05:28Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "I suggest the following wording for enhanced explanation and preciseness:\r\n\r\n\"As always when using CMS EnvelopedData to deliver encrypted content, the sender needs to let the recipient know which asymmetric key was used for the encryption. Usually this is done by identifying a certificate of the recipient using the issuer and serial number fields or the subject key identifier field contained in the certificate. Yet in the case of encrypting the newly issued certificate with the public key contained in that certificate, the recipient cannot use any of these fields because it does not yet have access to them before decrypting the certificate.\r\nTo solve this problem, an identifier needs to be chosen that can be computed by both the sender and the recipient without knowing the newly issued certificate.\r\nMethod 4 from RFC 7093 Section 2 with SHA-256 SHALL be applied. That is, the `RecipientIdentifier` MUST contain the `subjectKeyIdentifier` choice, with its value being the SHA-256 hash for the DER encoding of the `SubjectPublicKeyInfo` contained in the certificate signing request.\"",
          "createdAt": "2024-06-14T19:22:50Z",
          "updatedAt": "2024-06-28T10:58:08Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you David, I took some of you proposaly.\r\n\"Note that when delivering the newly issued certificate in encrypted form, the sender requires to let the recipient know which (private) key to use when decrypting the certificate. For asymmetric keys, CMS `EnvelopedData` is identifying a certificate of the recipient using the issuer and serial number fields or the subject key identifier field contained in the certificate to identify this key pair. As the recipient receives the newly issued certificate in encrypted form, the recipient cannot use any content of that certificate for identifying the private key to utilize for decryption. Therefore, the sender and recipient MUST use a SHA-256 hash of the DER encoding of the `SubjectPublicKeyInfo` contained in the certificate signing request to fill in the `SubjectKeyIdentifier` choice of `RecipientIdentifier.` This utilizes SHA-256 with method 4 from RFC 7093 Section 2.\"",
          "createdAt": "2024-06-17T13:40:36Z",
          "updatedAt": "2024-06-17T13:40:36Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the best way to identify the newly generated key pair to use for decrypting the EnvelopedData containing the new certificate using\r\n-\ttransactionID and certReqId from the CMP message header and the certificate request object or\r\n-\trecipient identifier in the recipienInfo with a fixed method for generation by sender and recipient and not the subject key identifier from the new certificate?\r\n\r\nThe first procedure only affects the recipient and not the sender of the message.",
          "createdAt": "2024-06-19T06:08:19Z",
          "updatedAt": "2024-06-19T06:08:19Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the second option, as it makes no assumptions on how an implementation may need to use the transactionID or certReqId.   \r\n\r\nI combined the text you and Daivd suggest above Hendrik:\r\n\r\nWhen delivering the newly issued certificate in encrypted form, the sender needs to let the recipient know which asymmetric private key to use when decrypting the certificate.  Normally the recipients private key is identified by using the issuer and serial number or subject key identifier fields contained in its associated public certificate, but this is not possible when the certificate itself is received in encrypted form.   Therefore, the sender and recipient MUST use a SHA-256 hash of the DER encoding of the SubjectPublicKeyInfo contained in the certificate signing request to fill in the SubjectKeyIdentifier choice of RecipientIdentifier. This utilizes SHA-256 with method 4 from RFC 7093 Section 2.\r\n\r\n",
          "createdAt": "2024-06-24T16:39:36Z",
          "updatedAt": "2024-06-24T16:39:36Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "To me, the first option appears best for two reasons.\r\n* The sender is free do whatever it usually does anyway when sending CMS encrypted stuff (no changes needed on this end).\r\n* The way to select the decryption key on the receiver end is straightforward: it is the private key related to the currently requested certificate. In nearly all cases, this trivially is the one key for which a cert is being requested. \r\nJust in the rare case a CMP request contained multiple CRMF requests the certReqId needs to be taken into account, and also this does not require implementing a new form of key identifier as proposed in the section option.",
          "createdAt": "2024-06-25T06:48:26Z",
          "updatedAt": "2024-06-25T06:48:26Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your proposals. I see @russhousley, @rajeev-0, and @johngray-dev  in favor of the second option and @DDvO in favor of the first option.\r\n@primetomas, @dghgit, and @ralienpp, is there anything you want to add?\r\nDoes anyone wants to comment on @DDvO arguments?\r\n\r\nIt would be great to conclude on this topic before the submission-cutoff for next IETF.",
          "createdAt": "2024-06-26T06:51:28Z",
          "updatedAt": "2024-06-26T06:51:28Z"
        },
        {
          "author": "dghgit",
          "authorAssociation": "NONE",
          "body": "I'd also go with the second.\r\n\r\nIt's true the receiver could try winging it, but it's always good to have a sanity check.\r\n\r\n\r\n\r\n",
          "createdAt": "2024-06-26T07:13:13Z",
          "updatedAt": "2024-06-26T07:13:13Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I missed the feedback from @primetomas on email. I copied the text in this comment below. But I do not see a clear preference for one or the other option.\r\n\r\n\"I did see that question. As you noted, any method that the client and server can generate independently without the client needing to receive the full response would work.\r\nTransaction and reqID are well known in CMP, and mandatory, so should be easy to use\r\n Rec keyid may be useful for carrier pidgeon transport, if the client looses state?\r\n\r\nFor implementation i think it's helpful to specify a mandatory option to avoid making it more complex than it is for clients and servers, having to implement lots of checks for different possibilities.\r\n\r\nRegards,\r\nTomas\"",
          "createdAt": "2024-06-26T07:26:50Z",
          "updatedAt": "2024-06-26T07:26:50Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am definitely planning for a clear specification and normative text her to prevent the implementations check for different options.\r\nCurrently I do see a clear preference for option 2 using the SHA-256 hash of the DER-encoded SubjectPublicKey structure as recipient key identifier. I also like the text proposed by @johngray-dev.\r\n\r\nDoes anyone still want to respond to @DDvO points in order to convince him?",
          "createdAt": "2024-06-26T07:32:51Z",
          "updatedAt": "2024-06-26T07:32:51Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> Transaction and reqID are well known in CMP, and mandatory, so should be easy to use\r\n\r\nYes, they are.\r\n\r\n> Rec keyid may be useful for carrier pidgeon transport, if the client looses state?\r\n\r\nIf the client ever loses its transaction state, it would be lost anyway. \r\n(And BTW this does not happen practice - I can say this with nearly 10 years of experience with various CMP clients.)\r\n\r\nSo the first option is most painless and pretty much a no-brainer for both clients and server.\r\nUpdate: I meanwhile had a look at the OpenSSL CMS documentation and implementation and found that for all key management techniques supported so far (which does not yet include KEM), it is assumed that the private key to use for decryption is pre-determined (by the application layer calling CMS, which in our case is CMP).\r\n\r\n> It's true the receiver could try winging it, but it's always good to have a sanity check.\r\n\r\nI do not see the need for an extra sanity check (using a key identifier or the like).\r\nThe client knows for sure which key(s) it used in the request.\r\n",
          "createdAt": "2024-06-26T20:11:21Z",
          "updatedAt": "2024-06-28T11:44:18Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DDvO I see you point. Thank you for explaining it further.\r\n\r\n@russhousley @rajeev-0 @johngray-dev @DDvO @primetomas @dghgit @ralienpp @ounsworth @carl-wallace \r\nHow do we get to a conclusion now?\r\n\r\n@russhousley Is there a procedure to reach consensus?",
          "createdAt": "2024-06-28T07:04:06Z",
          "updatedAt": "2024-06-28T07:04:06Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "The origin of this issue is that all respective texts so far (more or less) assume that the recipient/receiver already has (direct access to) a certificate that is used to (indirectly) refer to the key to use for decryption:\r\n\r\n* paragraph on KEM use in Section 5.2.2:\r\n\r\n> recipient's certificate with an algorithm identifier and a public key that supports key encapsulation mechanism and where any given key usage extension allows keyEncipherment: The content-encryption key will be protected using the key management technique for KEM keys, as specified in [[I-D.ietf-lamps-cms-kemri](https://datatracker.ietf.org/doc/html/draft-ietf-lamps-cms-kemri-08)].\r\n\r\n* the following paragraph in the cms-kemri draft section 3 - writes \"certificate or key\" initially, but the rest of the paragraph keeps talking about certificates, also for the `subjectKeyIdentfier` case, which gives the wrong impression that access to certificate is needed there, too:\r\n\r\n>  rid specifies the recipient's certificate or key that was used by\r\n      the originator with the KEM Encapsulate() function.  The\r\n      RecipientIdentifier provides two alternatives for specifying the\r\n      recipient's certificate [RFC5280], and thereby the recipient's\r\n      public key.  The recipient's certificate MUST contain a KEM public\r\n      key.  Therefore, a recipient X.509 version 3 certificate that\r\n      contains a key usage extension MUST assert the keyEncipherment\r\n      bit.  The issuerAndSerialNumber alternative identifies the\r\n      recipient's certificate by the issuer's distinguished name and the\r\n      certificate serial number; the subjectKeyIdentifier alternative\r\n      identifies the recipient's certificate by a key identifier.  When\r\n      an X.509 certificate is referenced, the key identifier matches the\r\n      X.509 subjectKeyIdentifier extension value.  When other\r\n      certificate formats are referenced, the documents that specify the\r\n      certificate format and their use with the CMS must include details\r\n      on matching the key identifier to the appropriate certificate\r\n      field.  For recipient processing, implementations MUST support\r\n      both of these alternatives for specifying the recipient's\r\n      certificate.  For originator processing, implementations MUST\r\n      support at least one of these alternatives.\r\n\r\n* BTW, also the paragraph in the CMS RFC section 6.2.1 (which does not really apply here but served as the source of the former) writes \"certificate or key\" initially, but the rest of the paragraph keeps talking about certificates, also for the `subjectKeyIdentfier` case, which gives the wrong impression that access to certificate is needed there, too:\r\n\r\n> rid specifies the recipient's certificate or key that was used by\r\n      the sender to protect the content-encryption key.  The content-\r\n      encryption key is encrypted with the recipient's public key.  The\r\n      RecipientIdentifier provides two alternatives for specifying the\r\n      recipient's certificate, and thereby the recipient's public key.\r\n      The recipient's certificate must contain a key transport public\r\n      key.  Therefore, a recipient X.509 version 3 certificate that\r\n      contains a key usage extension MUST assert the keyEncipherment\r\n      bit.  The issuerAndSerialNumber alternative identifies the\r\n      recipient's certificate by the issuer's distinguished name and the\r\n      certificate serial number; the subjectKeyIdentifier identifies the\r\n      recipient's certificate by a key identifier.  When an X.509\r\n      certificate is referenced, the key identifier matches the X.509\r\n      subjectKeyIdentifier extension value.  When other certificate\r\n      formats are referenced, the documents that specify the certificate\r\n      format and their use with the CMS must include details on matching\r\n      the key identifier to the appropriate certificate field.  For\r\n      recipient processing, implementations MUST support both of these\r\n      alternatives for specifying the recipient's certificate.  For\r\n      sender processing, implementations MUST support at least one of\r\n      these alternatives.\r\n      \r\nIt would be good if these were extended to explicitly describe or reference a proper handling of the case where the sender directly references a public key (rather than a certificate), providing a default method for computing the `SubjectKeyIdentifier`. \r\nBTW, when using the `subjectKeyIdentifier` choice, my preference would be to use from RFC 7093 Section 2 not method 4, but method 1 because it is simpler (does not use an extra level of DER encoding) and already implies the use of SHA256. Anyway, note that for the specific use case of identifying a public key for CMS encryption, the old method using 160-bit SHA-1 as described in RFC 5280 would still work perfectly fine as well.\r\n\r\nIf this is done in [KEMRI section 3](https://www.ietf.org/archive/id/draft-ietf-lamps-cms-kemri-08.html#section-3), I'd be fine with using the second option here\r\nbecause then for both sides a default way of directly referencing a key via a `SubjectKeyIdentfier` is defined already at CMS level, and doing the key selection at application level (using CMP transaction details) is then clearly not needed.\r\nThen it will be sufficient to require (and explain why, as already suggested) that for the special use case of sending an encrypted cert, the `subjectKeyIdentifier` choice of the `RecipientIdentifier` MUST be used, applying the default method of computing the key identifier value.",
          "createdAt": "2024-06-28T09:49:16Z",
          "updatedAt": "2024-06-28T11:17:23Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "On further thoughts, I've extended the text and revised the final part of my most recent comment.",
          "createdAt": "2024-06-28T10:31:55Z",
          "updatedAt": "2024-06-28T11:18:01Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Is anyone aware of a CMS implementation that already provides the possibility for a *sender* application to specify the RecipientIdentifier in a way independent of a recipient certificate?\r\n\r\nOpenSSL does not. \r\nSo when adding KEM support, going for option 2, this would be required to add to the implementation.",
          "createdAt": "2024-06-28T12:42:14Z",
          "updatedAt": "2024-06-28T12:42:14Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "Is anyone aware of a CMS implementation that does not provide a way for the *receiver* application to pre-select the private key to use for decryption?\r\n\r\nFor the key management mechanisms so far supported by OpenSSL, this is the only way to do it.\r\n\r\nAnd does anyone know of a CMS implementation that enables the receiver to hand in a key identifier for an asymmetric key that is independent of a cert?\r\n\r\nOpenSSL does not. \r\n\r\nOne can in addition provide a related certificate, which is then used for a sanity check matching the cert with the RecipientIdentifier(s),  but so far no sanity check is implemented that works without a certificate - \r\nthe existing implementation does the same thing that the hitherto CMS spec(s) assume: \r\nthey take the SubjectKeyIdentifier from any cert provided by the application.",
          "createdAt": "2024-06-28T12:42:21Z",
          "updatedAt": "2024-06-28T12:42:21Z"
        },
        {
          "author": "carl-wallace",
          "authorAssociation": "NONE",
          "body": "I've written code that allows for searching a key store for a match against a recipient identifier and code that allows pre-selection. I have not written code that allows for creation of a recipient identifier independent of a certificate, but that's not the case here. The server has the cert. \r\n\r\nWhy is a SKID calculated per a standard mechanism a problem? The server will have the certificate, the client will not, but will have the public key and can calculate the SKID. As has been noted many times in this thread, in the common case there is only one key that makes sense for the client to use and a SKID calculated on the key can provide a sanity check for folks that want it. Folks who don't want it, can wing it. I am missing what the issue is.\r\n\r\n",
          "createdAt": "2024-06-28T14:01:45Z",
          "updatedAt": "2024-06-28T14:01:45Z"
        },
        {
          "author": "russhousley",
          "authorAssociation": "NONE",
          "body": "@Hendrik: Consensus will not be determined in a GitHub issue discussion.  You have two ways forward. You either describe the alternatives in a message to the mail list or you pick one and put it in the document.  The first one allows for a very narrow discussion.  The second one has the possibility of discussing this issue and others at the same time.",
          "createdAt": "2024-06-28T14:39:00Z",
          "updatedAt": "2024-06-28T14:39:00Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> I've written code that allows for searching a key store for a match against a recipient identifier and code that allows pre-selection. I have not written code that allows for creation of a recipient identifier independent of a certificate, but that's not the case here. The server has the cert.\r\n\r\nSure the sender/server has the cert, but the client/recipient does not (yet) know it before decrypting it, for which it needs to determine which key to use in advance. So any key identification based on the cert contents does not work (yet). \r\n\r\nIn my opinion it is sufficient and clearly more straightforward to use the first option suggested to determine the right key to use at application level, independent of the CMS level. This effectively ignores the identifier inserted by the sender. \r\n\r\n> Why is a SKID calculated per a standard mechanism a problem? The server will have the certificate, the client will not, but will have the public key and can calculate the SKID. As has been noted many times in this thread, in the common case there is only one key that makes sense for the client to use and a SKID calculated on the key can provide a sanity check for folks that want it. Folks who don't want it, can wing it. I am missing what the issue is.\r\n\r\nAs there is no such thing as *the* SKID of a given public key (there are just more or less common ways of computing some useful SKID) and the method is not made explicit, the receiver would not know which method to use for computing it. \r\n\r\nThe suggested second option would provide a unique way for computing a specific SKID. Yet this makes things more complicated for implementations with no real gain (just a pretty redundant sanity checking). ",
          "createdAt": "2024-06-28T15:29:19Z",
          "updatedAt": "2024-06-28T15:56:26Z"
        },
        {
          "author": "carl-wallace",
          "authorAssociation": "NONE",
          "body": "> Sure the sender/server has the cert, but the client/recipient does not (yet) know it before decrypting it\r\n\r\nIf the SKID value can be calculated from the public key via a mechanism that assures both the client and the server arrive at the same value, how does it matter that the client does not have the cert? The client obviously has the public key value because it generated the public key value.\r\n\r\n> the receiver would not know which method to use for computing it\r\n\r\nThe point is that the authors of this spec write down how to compute it. There are not \"more or less common ways\", you pick one and write it down.\r\n\r\nI think you are saying is that if you assume that SKIDs can be any old value that the server elects and the client cannot know the value and thus cannot avail itself of this sanity check. This is true. So don't do that. Either codify a way to calculate the SKID *when using this new spec* or elect to not have a sanity check. \r\n\r\nIf you are electing to allow the server a free hand in choosing SKID values (or to use issuer/serial recipient key identifier) then you are either sacrificing the sanity check or you are adding a new recipient identifier choice (based on transaction ID or something else). I think you are electing to not have a sanity check. That may be OK, write it down. To my eye, the simplest path is to not allow the server a free hand in choosing SKID values.",
          "createdAt": "2024-06-28T15:56:08Z",
          "updatedAt": "2024-06-28T15:56:08Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> > Sure the sender/server has the cert, but the client/recipient does not (yet) know it before decrypting it\r\n> \r\n> If the SKID value can be calculated from the public key via a mechanism that assures both the client and the server arrive at the same value, how does it matter that the client does not have the cert? The client obviously has the public key value because it generated the public key value.\r\n\r\nSure this works, and is what has been suggested as the 2nd option.\r\n \r\n> > the receiver would not know which method to use for computing it\r\n> \r\n> The point is that the authors of this spec write down how to compute it. There are not \"more or less common ways\", you pick one and write it down.\r\n\r\nYes, but as I've been conveying to those favouring this approach, this comes at extra cost:\r\nIt needs to be specified that a certain method has to be used, \r\nthis needs to be implemented on both sender and receiver side\r\n(and there is also a minor computational penalty computing the DER encoding and hash value).\r\n\r\n> I think you are saying is that if you assume that SKIDs can be any old value that the server elects and the client cannot know the value and thus cannot avail itself of this sanity check. This is true. So don't do that. Either codify a way to calculate the SKID _when using this new spec_ or elect to not have a sanity check.\r\n\r\nBasically yes (though in theory even when not going for the 2nd suggested option, after the receiver decrypted the cert, it could do the sanity check in retrospect, yet in this case the CMS level has already been left, which would make it more hard to do at that point, and IMO the benefit of the sanity check is negligible).\r\n\r\n> If you are electing to allow the server a free hand in choosing SKID values (or to use issuer/serial recipient key identifier) then you are either sacrificing the sanity check or you are adding a new recipient identifier choice (based on transaction ID or something else). I think you are electing to not have a sanity check. That may be OK, write it down. To my eye, the simplest path is to not allow the server a free hand in choosing SKID values.\r\n\r\nYes, this is my preference and also my advice from implementer's perspective: \r\nlet the server do whatever it is accustomed to do providing any (direct or indirect) key identifier, and the receiver simply ignores it.\r\nThis is sufficient and does not require extra specification effort, and - more importantly - no extra implementation effort.",
          "createdAt": "2024-06-28T16:38:19Z",
          "updatedAt": "2024-06-28T16:48:04Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "In fact, the choice to make is not whether to use\r\n* transactionID and certReqId from the CMP message header and the certificate request object \r\n**or**\r\n* recipient identifier in the recipienInfo with a fixed method for generation by sender and recipient and not the subject key identifier from the new certificate?\r\n\r\nbut whether to use only the first item or *in addition* also the second item.\r\nThis is because, in practice, the CMP client will always have to tell the CMS library/layer which private key (it expects the CMS layer) to use for decrypting the CMS encrypted cert. \r\n\r\nThe only thing the CMS lib may do in case the section item is implemented is to (sanity-)check in addition that the received RecipientIdentifier agrees with that.\r\n\r\nYet even if this check is performed, such that it gets confirmed that sender and receiver agree on the key to use for decryption, this is not sufficient to guarantee that the decryption works fine (because many other things may have gone wrong).\r\nSo anyway the decrypted cert will need to be sanity-checked, at the latest at application level.\r\nAnd when this succeeds, among others the correct choice of the decryption key is indirectly confirmed.\r\nThis is why I see (little to) no real value in spending the effort to come up with a RecipientIdentifier that the receiver can use to sanity-check in advance the agreement on the decryption key.\r\n\r\nAlso note that the CMS encryption is part of a CMP message, the origin of which will already have been verified by the receiver before it involves the CMS lib. So at this point it is already clear that the encrypting party is authorised to send CMP messages with responses that ask for indirect POP by cert decryption,\r\nand thus we do not need to defend at CMS level against nifty decryption oracle attacks or the like.",
          "createdAt": "2024-06-29T08:38:40Z",
          "updatedAt": "2024-06-29T08:40:41Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue was solved with V12",
          "createdAt": "2024-07-12T15:00:46Z",
          "updatedAt": "2024-07-12T15:00:46Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOInbtzM6Rb1aF",
      "title": "Direct POP - hash of Rand instead of plain INTEGER",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/63",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Coming back to the discussion in the LAMPS session.\r\nIn the Direct POP in CMC the hash of the challenge is returned. If I got it right, it was mentioned that it may not be secure, if the challenge is responded in plain.\r\n\r\nIn CMP Rand containing a sequence of an INTEGER and the sender's GeneralName is the challenge and is provides as EnvelopedData. In the response the INTEGER is returned in plain.\r\n\r\nIf people think this is insecure, we should update the response to responding the hash of Rand. \r\nThis was also a proposal from Thom Wiggers.",
      "createdAt": "2024-07-31T12:54:46Z",
      "updatedAt": "2024-09-05T15:51:16Z",
      "closedAt": "2024-09-05T15:42:17Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mike responded on email:\r\nCMC says this for the direct POP challenge response:\r\n\r\n     DecryptedPOP ::= SEQUENCE {\r\n           bodyPartID     BodyPartID,\r\n           thePOPAlgID    AlgorithmIdentifier,\r\n           thePOP         OCTET STRING\r\n      }\r\n\r\n       thePOPAlgID  identifies the algorithm to be used in computing the\r\n           return POP value.\r\n       thePOP  contains the possession proof.  This value is computed by\r\n          the POPAlgID using the POP Proof Value and the request.\r\n\r\nAnd the example shows:\r\n\r\n             thePOPAlgID HMAC-SHA1,\r\n             thePOP <HMAC computed value goes here>}}\r\n\r\nIt would not be a terrible idea to do the same thing in CMP. I\u2019m not sure that it is exactly an attack since in CMP an attacker would also need to be able to forge the overall HMAC message protection, but it is maybe a good idea to align with CMC?",
          "createdAt": "2024-07-31T12:59:32Z",
          "updatedAt": "2024-07-31T12:59:32Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the CMP request message can be extended easily. But extending the existing response message will not work. Therefore we either need to redefine the existing response message with CMP V3 or we need to define a new response message.\r\n\r\n**Current syntax according to rfc4210bis:**\r\n\r\nPKIBody ::= CHOICE {       -- message-specific body elements\r\n\u2026\r\n    popdecc  [5]  POPODecKeyChallContent, --pop Challenge\r\n    popdecr  [6]  POPODecKeyRespContent,  --pop Response\r\n\u2026\r\n}\r\n\r\nPOPODecKeyChallContent ::= SEQUENCE OF Challenge\r\n-- One Challenge per encryption or key agreement key certification\r\n-- request (in the same order as these requests appear in\r\n-- CertReqMessages).\r\n\r\n-- encryptedRand was added in [RFCXXXX]\r\n\r\nChallenge ::= SEQUENCE {\r\n   owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\r\n                            OPTIONAL,\r\n   -- MUST be present in the first Challenge; MAY be omitted in\r\n   -- any subsequent Challenge in POPODecKeyChallContent (if\r\n   -- omitted, then the owf used in the immediately preceding\r\n   -- Challenge is to be used).\r\n   witness             OCTET STRING,\r\n   -- the result of applying the one-way function (owf) to a\r\n   -- randomly-generated INTEGER, A. (Note that a different\r\n   -- INTEGER MUST be used for each Challenge.)\r\n   challenge           OCTET STRING,\r\n   -- MUST be used for cmp2000(2) popdecc messages and MUST be\r\n   -- the encryption of Rand (using a mechanism depending on the\r\n   -- private key type).\r\n   -- MUST be an empty OCTET STRING for cmp2021(3) popdecc messages.\r\n   -- Note: Using challenge omitting the optional encryptedRand is\r\n   -- bit-compatible to the syntax without adding this optional\r\n   -- field.\r\n   encryptedRand   [0] EnvelopedData OPTIONAL\r\n   -- MUST be omitted for cmp2000(2) popdecc messages.\r\n   -- MUST be used for cmp2021(3) popdecc messages and MUST contain\r\n   -- the encrypted value of Rand using CMS EnvelopedData using the\r\n   -- key management technique depending on the private key type as\r\n   -- defined in Section 5.2.2.\r\n}\r\n\r\n-- Rand was added in [RFC9480]\r\n\r\nRand ::= SEQUENCE {\r\n-- Rand is encrypted involving the public key to form the content of\r\n-- challenge or encryptedRand in POPODecKeyChallContent\r\n   int                  INTEGER,\r\n   -- the randomly generated INTEGER A (above)\r\n   sender               GeneralName\r\n   -- the sender's name (as included in PKIHeader)\r\n}\r\n\r\nPOPODecKeyRespContent ::= SEQUENCE OF INTEGER\r\n-- One INTEGER per encryption or key agreement key certification\r\n-- request (in the same order as these requests appear in\r\n-- CertReqMessages). The retrieved INTEGER A (above) is returned to\r\n-- the sender of the corresponding Challenge.\r\n\r\n\r\n**Updated Syntax:**\r\n\r\nPKIBody ::= CHOICE {       -- message-specific body elements\r\n\u2026\r\n    popdecc  [5]  POPODecKeyChallContent, --pop Challenge\r\n    popdecr  [6]  POPODecKeyRespContent,  --pop Response\r\n\u2026\r\n    popdecrV3 [27] POPODecKeyRespContentV3 \u2013 pop Response in CMP V3\r\n}\r\n\r\nPOPODecKeyChallContent ::= SEQUENCE OF Challenge\r\n-- One Challenge per encryption or key agreement key certification\r\n-- request (in the same order as these requests appear in\r\n-- CertReqMessages).\r\n\r\nChallenge ::= SEQUENCE {\r\n   owf                 AlgorithmIdentifier{DIGEST-ALGORITHM, {...}}\r\n                            OPTIONAL,\r\n   -- MUST be present in the first Challenge; MAY be omitted in\r\n   -- any subsequent Challenge in POPODecKeyChallContent (if\r\n   -- omitted, then the owf used in the immediately preceding\r\n   -- Challenge is to be used).\r\n   witness             OCTET STRING,\r\n   -- the result of applying the one-way function (owf) to a\r\n   -- randomly-generated INTEGER, A. (Note that a different\r\n   -- INTEGER MUST be used for each Challenge.)\r\n   challenge           OCTET STRING,\r\n   -- MUST be used for cmp2000(2) popdecc messages and MUST be\r\n   -- the encryption of Rand (using a mechanism depending on the\r\n   -- private key type).\r\n   -- MUST be an empty OCTET STRING for cmp2021(3) popdecc messages.\r\n   -- Note: Using challenge omitting the optional encryptedRand is\r\n   -- bit-compatible to the syntax without adding this optional\r\n   -- field.\r\n   encryptedRand   [0] EnvelopedData OPTIONAL,\r\n   -- MUST be omitted for cmp2000(2) popdecc messages.\r\n   -- MUST be used for cmp2021(3) popdecc messages and MUST contain\r\n   -- the encrypted value of Rand using CMS EnvelopedData using the\r\n   -- key management technique depending on the private key type as\r\n   -- defined in Section 5.2.2.\r\n   popAlgID     [1] AlgorithmIdentifier OPTIONAL\r\n   -- MUST be omitted for cmp2000(2) popdecc messages.\r\n   -- MUST be used for cmp2021(3) popdecc messages and MUST\r\n   -- identify the algorithm to be used in computing the return POP value.\r\n}\r\n\r\nRand ::= SEQUENCE {\r\n-- Rand is encrypted involving the public key to form the content of\r\n-- challenge or encryptedRand in POPODecKeyChallContent\r\n   int                  INTEGER,\r\n   -- the randomly generated INTEGER A (above)\r\n   sender               GeneralName\r\n   -- the sender's name (as included in PKIHeader)\r\n}\r\n\r\nPOPODecKeyRespContent ::= SEQUENCE OF INTEGER\r\n-- MUST be used for cmp2000(2) popdecr messages\r\n-- One INTEGER per encryption or key agreement key certification\r\n-- request (in the same order as these requests appear in\r\n-- CertReqMessages). The retrieved INTEGER A (above) is returned to\r\n-- the sender of the corresponding Challenge.\r\n\r\nPOPODecKeyRespContentV3 ::= SEQUENCE OF ChallengeResponse\r\n-- MUST be used for cmp2001(3) popdecrV3 messages\r\n-- One ChallengeResponse per encryption or key agreement key\r\n--  certification request (in the same order as these requests appear in\r\n-- CertReqMessages). The hash of the retrieved Rand including the\r\n-- INTEGER A (above) is returned to the sender of the corresponding\r\n-- Challenge.\r\n\r\nChallengeResponse ::= SEQUENCE {\r\n   popAlgID    AlgorithmIdentifier,\r\n   -- MUST be the value from Callenge\r\n   pop         OCTET STRING\r\n   -- MUST contain the possession proof. This value is computed by\r\n   -- the popAlgID using the Rand value.\r\n}\r\n\r\nIntroducing the new PKIBody choice popdecrV3 is not nice. Does anyone have a better idea?\r\n@johngray-dev  what do you think?\r\n",
          "createdAt": "2024-08-02T09:26:36Z",
          "updatedAt": "2024-08-02T09:26:36Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@johngray-dev Do you have any feedback to this issue?\r\n@ounsworth what do you think with regard to alignment with CMCbis?\r\n@DDvO do you have any opinion?\r\n\r\nAs the draft is already at IESG for AD review, we need to hurry, if we want to change anything here. Therefore, you quick feedback is appreciated! :-)\r\nI am also happy to close this issue without any further change to the draft if we feel like it is not needed.\r\nIf we decide to implement this change, it will most likely end up in a new WGLC. But this should not be the blocking point of course.\r\n",
          "createdAt": "2024-09-02T12:18:45Z",
          "updatedAt": "2024-09-02T12:25:16Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "For clarity, this must have been the concern raised by Thom on July 10th:\r\n\r\n> Regarding security consideration 8.2, have you considered returning H(rand) instead of rand to further avoid these decryption oracles? However, arguably the derivation of challenge encryption key should be set up in a way to sufficiently domain-separate this. Again, this comes back to how the challenge encryption keys are set up.",
          "createdAt": "2024-09-02T14:47:01Z",
          "updatedAt": "2024-09-02T14:47:01Z"
        },
        {
          "author": "DDvO",
          "authorAssociation": "NONE",
          "body": "> @johngray-dev Do you have any feedback to this issue? \r\n> @ounsworth what do you think with regard to alignment with CMCbis?\r\n> @DDvO do you have any opinion?\r\n> \r\n> As the draft is already at IESG for AD review, we need to hurry, if we want to change anything here. Therefore, you quick feedback is appreciated! :-) I am also happy to close this issue without any further change to the draft if we feel like it is not needed. If we decide to implement this change, it will most likely end up in a new WGLC. But this should not be the blocking point of course.\r\n\r\nI do not believe that there really is a security problem with the CMP client responding the decrypted challenge in plain (unencrypted non-hashed form).\r\n\r\nThe concern was that the unencrypted response could be used as part of a decryption oracle attack.\r\nThis would require sending many challenges (possibly even with specifically chosen input data).\r\n\r\nYet this cannot happen here because for a given private key, a cert request will be sent only once\r\n(or at least not often; even if the client later sent requests  for certificate updates using the same key pair, \r\nquite long time would have passed between any such requests),\r\nand a legitimate CMP server (typically, the CA) reacts with a direct POP challenge at most once for each cert request,\r\nand the client would accept such a challenge only once per cert request that it sent.\r\n\r\n(Moreover, direct POP requests by an illegitimate CMP server (posing as the CA) would be rejected by the client\r\nbecause such an attacker would not be able to provide valid CMP message protection.)\r\n\r\nThus I do not see the need for making any further (even worse, last-minute!) changes to the direct POP mechanism.\r\n\r\nAs far as you agree with this argumentation, it may be taken as the basis for a paragraph \r\nto be added regarding this concern in the security considerations section.\r\n",
          "createdAt": "2024-09-02T14:48:07Z",
          "updatedAt": "2024-09-02T14:51:14Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the concern would be a malicious entity that sent in the encrypted challenge many times (though they would have to know how to protect the message in the first place....).  You mention a legitimate CMP server will react with a direct POP challenge at most once for each cert request.  Is that stated anywhere?   If not then I maybe that just needs to be stated somewhere in normative language in the security concerns section.  That maybe overkill, but if it is a concern then we could say something like: \r\n\r\n - A CMP server MUST not respond to a direct POP challenge for a cert request more than once.   If a subsequent request for the same certificate request is received, the CMP server MUST send an error indicating a POP challenge has already been received for the specific cert request.\r\n\r\nIf the same cert requests should be allowed (as David mentioned maybe a re-keying of the same cert request), then maybe some type of retry interval should be recommended? \r\n\r\nThom's mentioned the following:\r\n\r\n- Regarding security consideration 8.2, have you considered returning H(rand) instead of rand to further avoid these decryption oracles? However, arguably the derivation of challenge encryption key should be set up in a way to sufficiently domain-separate this. Again, this comes back to how the challenge encryption keys are set up.\r\n\r\nAnother way to mitigate is we could say something like the key management technique should use sufficient context (domain separation) information when deriving the keys for the challenge.   We mention key transport, key agreement, password and KEM as key management techniques (Section 5.2.2).   Perhaps this is something to state in the security concerns section.  \r\n\r\nI thinking making a whole new PKIBody message with caveats when to use it may be a bit of overkill.  It would definitely solve the issue.  I guess we need to convince ourselves there is an issue to resolve first of all.   I think the biggest hurdle is the message protection, so unless we think that isn't sufficient, then we need to do something.   ",
          "createdAt": "2024-09-03T03:21:58Z",
          "updatedAt": "2024-09-03T03:21:58Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I thinking making a whole new PKIBody message with caveats when to use it may be a bit of overkill. It would definitely solve the issue. I guess we need to convince ourselves there is an issue to resolve first of all. I think the biggest hurdle is the message protection, so unless we think that isn't sufficient, then we need to do something.\r\n\r\nIn fact, it is not only with Direct POP that we have the situation that data is transmitted from the CMP server to the CMP client, where the data has been encrypted with the public key of the CMP client. This is also the case with indirect POP and central key generation, where the certificate or private key is transmitted in encrypted form. In the opposite direction, CMS EnvelopdData from the CMP client to the CMP server is also specified for the transfer of revocation passphrases and private keys as POP and for key escrow/recovery. In all these cases, we rely on the security of CMS Enveloped Data!\r\nSpontaneously, I see no reason why we should rely less on the security of CMS Enveloped Data for Direct POP and take special precautions. If we don't trust in the security of CMS EnvelopedData, we have a much bigger problem elsewhere, especially with transferal of private keys. The transfer of H(Rand) would be cryptographically nicer, but the change to the syntax would be ugly, and we would only address a potential problem for a corner case.\r\nIf you agree, I vote for not changing from Rand --> H(Rand).\r\nOr am I missing something here?\r\nPlease add you vote as comment.",
          "createdAt": "2024-09-03T17:06:11Z",
          "updatedAt": "2024-09-03T17:06:11Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The analysis in my previous comment was not entirely complete.\r\n\r\nYes, we rely on the security of CMS EnvelopedData in all the cases listed above. But only in two cases can an attacker simply have access to ciphertext and plaintext.\r\n- Indirect POP: The attacker would have to obtain the new certificate in plain from other communications. In certConf, only H(certificate) is transmitted.\r\n- Direct POP: The attacker gets ciphertext and plaintext from the Rand of the same transaction.\r\n\r\nI think that's what makes the difference. The question now is, should we take countermeasures?\r\nIn both cases, the content of the ciphertext must have a valid ASN.1 structure. This MUST be checked by the CMP client, as stated in Section 8.2. An attacker also cannot choose the ciphertext if the message is signed by the CMP server.\r\n\r\nPossible countermeasures could be the following:\r\n1. Answer H(Rand) instead of Rand\r\n2. Expand Section 8.2 with a security consideration that a CMP server MUST only provide an encrypted challenge/certificate once for a given public-private key pair.\r\n3. Note that in the cases described above, sufficient domain separation must be applied to the key management technique used. At the moment, it is not quite clear to me how we can specify this simply and unambiguously.\r\n4. Message protection by the CMP server is required for POPODecKeyChallContent messages.\r\n5. No further countermeasures if we believe that the attack is sufficiently unlikely.\r\n\r\n@johngray-dev , @ounsworth , and @DDvO \r\nWhat do you think? Do you have anything else to add to this analysis?\r\nIf not, what countermeasure do you vote for?",
          "createdAt": "2024-09-03T19:07:26Z",
          "updatedAt": "2024-09-03T19:07:26Z"
        },
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "DDvO\r\n\r\n> I do not believe that there really is a security problem with the CMP client responding the decrypted challenge in plain (unencrypted non-hashed form).\r\n\r\nUltimately, I think I agree with this.\r\n\r\nI think we have now considered it, and it is not worth the effort to make any change.",
          "createdAt": "2024-09-04T20:06:15Z",
          "updatedAt": "2024-09-04T20:06:15Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks to all of you for responding to this issue. I am also fine with changing nothing further.\r\nIf I got John's and David's comments right, they are also not convinced that there is need for action.\r\nPlease reopen this issue if you think we need further discussion.",
          "createdAt": "2024-09-05T15:42:17Z",
          "updatedAt": "2024-09-05T15:42:17Z"
        },
        {
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "body": "I am okay with this outcome.   If it were to come up again during the write-up processes we could add a sentence to security considerations.   ",
          "createdAt": "2024-09-05T15:51:15Z",
          "updatedAt": "2024-09-05T15:51:15Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOInbtzM6mSqjF",
      "title": "How to address Paul's DISCUSS issue",
      "url": "https://github.com/lamps-wg/cmp-updates/issues/65",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "If we change the terminology in rfc4210bis, the following must be checked for breaking changes first:\r\n\r\n- RFC 9483 (Lightweight CMP Profile), RFC 9481 (CMP Algorithms), RFC 9482 (CoAP transfer for CMP), BRSKI-AE and  rfc6712bis (HTTP transfer for CMP), and  BRSKI-AE\r\n- All further references of RFC 4210, see https://datatracker.ietf.org/doc/rfc4210/referencedby/",
      "createdAt": "2025-01-15T13:52:30Z",
      "updatedAt": "2025-01-28T11:36:09Z",
      "closedAt": "2025-01-28T11:36:07Z",
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I checked all references of RFC 4210.\nRoughly twice as many documents use 'trusted CA' or 'trust anchor' than 'root CA'.\nTwo I-D could to adapt its terminology.\nRFC 7030 and RFC 9483 would need a erratum to state this change for a potential future update.\nRFC 8994 anyhow got the reference wrong and needs an erratum.\nFor details see the attached PDF [References to RFC4210 root CA terminology.pdf](https://github.com/user-attachments/files/18442717/References.to.RFC4210.root.CA.terminology.pdf).",
          "createdAt": "2025-01-16T16:30:31Z",
          "updatedAt": "2025-01-22T07:08:17Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did potential changes removing the terminology \"root CA\" in the PR #66 \nI just gave it a try and my not be perfect.\n\n@John, @ Mike, @David, what do you think, is it worth bringing this PR to the attention of the ADs or will it course too much discussion.",
          "createdAt": "2025-01-16T16:35:15Z",
          "updatedAt": "2025-01-16T16:35:15Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "John and David reviewed PR #66 but both still question the need for this change.\nI prepared PR #67 containing the changes for Option 2.",
          "createdAt": "2025-01-22T07:08:31Z",
          "updatedAt": "2025-01-22T07:08:31Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I incorporated change requests from David into #67.\n@johngray-dev , @ounsworth do you have any further comment on #67? Shall I go ahead with this change addressing Paul's DISCUSS?",
          "createdAt": "2025-01-22T07:11:09Z",
          "updatedAt": "2025-01-22T07:11:09Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I merged #67 as it is the preferred option to handle Paul's DISCUSS",
          "createdAt": "2025-01-27T11:57:13Z",
          "updatedAt": "2025-01-27T11:57:13Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is agreement among the authors to submit the version containing #67.",
          "createdAt": "2025-01-28T11:36:07Z",
          "updatedAt": "2025-01-28T11:36:07Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOInbtzM5Ft3B5",
      "title": "KEM combiner reduction",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/1",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "HBrock"
      ],
      "labels": [],
      "body": "I wrote a paragraph that does a security reduction of this KEM combiner to draft-ounsworth-cfrg-kem-combiner.",
      "createdAt": "2022-12-18T00:43:13Z",
      "updatedAt": "2022-12-20T09:40:28Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "22e82936eef53f15418d6c352411c90762b8451b",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "mike_kem_reduction",
      "headRefOid": "261e10590b8119c52995aeb878c1c8f3c6869029",
      "closedAt": "2022-12-20T09:40:28Z",
      "mergedAt": "2022-12-20T09:40:28Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "2e484d625646636dc6de31991ee2a8397ffab542"
      },
      "comments": [
        {
          "author": "ounsworth",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@HBrock I wrote some text, but I am not very familiar with the XML I-D format. Are you willing to add the cross-references, and move some of that text into an appendix?",
          "createdAt": "2022-12-18T00:44:40Z",
          "updatedAt": "2022-12-18T00:44:40Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @HBrock [...] move some of that text into an appendix?\r\n\r\nThank you for your proposal. I will merge it. Should I move the text to a new Section 8.8 or should I introduce a new Appendix C?",
          "createdAt": "2022-12-19T07:02:52Z",
          "updatedAt": "2022-12-19T07:02:52Z"
        },
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will merge your changes.\r\nAfter the merge I will update the references and move the second paragraph to the Security Considerations section.",
          "createdAt": "2022-12-20T09:40:08Z",
          "updatedAt": "2022-12-20T09:40:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOInbtzM5JVyxl",
      "title": "Do not hypenate across EoL",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/12",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Otherwise, the HTML versions of the document will have spaces like ``proof-of- posession``.",
      "createdAt": "2023-02-06T13:39:46Z",
      "updatedAt": "2023-02-07T07:53:23Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "9b6f9a1b31603c8082e025ac0ae9637fa73a69f9",
      "headRepository": "thomwiggers/cmp-updates",
      "headRefName": "thomwiggers/no-hypenate-across-eol",
      "headRefOid": "18892e3bb2d4814a155fe04d7a1cc747c0e7427e",
      "closedAt": "2023-02-07T07:53:23Z",
      "mergedAt": "2023-02-07T07:53:23Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "668e149df6066d5d40e1177a5017cd38b3192e9d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOInbtzM5JV3Z6",
      "title": "Fix a minor typo (the uses KDF  -> the used KDF)",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/13",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-06T13:54:29Z",
      "updatedAt": "2023-02-07T07:50:31Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "9b6f9a1b31603c8082e025ac0ae9637fa73a69f9",
      "headRepository": "thomwiggers/cmp-updates",
      "headRefName": "thomwiggers/typos",
      "headRefOid": "7b95ad4193d2885f69991ccd9279b39765ce375a",
      "closedAt": "2023-02-07T07:50:31Z",
      "mergedAt": "2023-02-07T07:50:31Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "793b5c214b3f0027e6a1f39060d817ea2f55ded6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOInbtzM5PM8o_",
      "title": "Fix a typo",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/19",
      "state": "MERGED",
      "author": "ralienpp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-26T13:38:27Z",
      "updatedAt": "2023-05-03T11:07:20Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "c6cdad8c160221899bfbd03a4f7a2b5cba5d1ca1",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "ralienpp-patch-typo",
      "headRefOid": "dda68c274d73c668662947afb80614d00445c8e7",
      "closedAt": "2023-05-03T11:07:20Z",
      "mergedAt": "2023-05-03T11:07:20Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "344704786c66f836e22e909f30ecf9d7756e2db4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "PR_kwDOInbtzM5QdrRU",
      "title": "Updated POP necessity references",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/27",
      "state": "MERGED",
      "author": "ounsworth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-15T00:54:50Z",
      "updatedAt": "2024-10-02T16:00:00Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "74e9882608d1e227a70e232547592fad38c0b976",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "mike_edits",
      "headRefOid": "316ca7c1cf09ba19619617f311bac1b4464b48f6",
      "closedAt": "2023-05-17T14:34:49Z",
      "mergedAt": "2023-05-17T14:34:49Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "7e9a99fa44e7d46cbbf01768e0eca9689cbb98ac"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOInbtzM5Tcziv",
      "title": "Fix typo",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/29",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-20T15:10:36Z",
      "updatedAt": "2023-06-21T06:14:49Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "462037c223edc3816f371e08e0580348c032ca1e",
      "headRepository": "thomwiggers/cmp-updates",
      "headRefName": "patch-1",
      "headRefOid": "aa1f21a0fff0cd92e1e636baf5dc73b3ab5862be",
      "closedAt": "2023-06-21T06:14:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOInbtzM5YzRpy",
          "commit": {
            "abbreviatedOid": "aa1f21a"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for reporting this.",
          "createdAt": "2023-06-21T06:14:32Z",
          "updatedAt": "2023-06-21T06:14:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOInbtzM5dYXux",
      "title": "Clarify references to KEM definition and genm/genp usage in Section 5.1.3.4",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/36",
      "state": "CLOSED",
      "author": "kiron-mx",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-20T13:07:21Z",
      "updatedAt": "2023-11-27T12:43:32Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "4bccf65be27ac32f90dd83a2964c607ae9793e90",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "kiron-kem-references",
      "headRefOid": "8e9de5f794eef3dcf2cdd911a53a3b2a2263c5d6",
      "closedAt": "2023-11-27T12:43:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cherry-picked your changes",
          "createdAt": "2023-11-27T12:43:32Z",
          "updatedAt": "2023-11-27T12:43:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 47,
      "id": "PR_kwDOInbtzM5nRMRG",
      "title": "Fixed some typos, punctuation and broken links",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/47",
      "state": "MERGED",
      "author": "kiron-mx",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-19T10:11:16Z",
      "updatedAt": "2024-02-21T07:18:06Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "3d6dd3e9b4957c3909a524d446d1a96a2c13226b",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "kiron-typos-and-links",
      "headRefOid": "727ae7e26077128675667922188a8432e31a355a",
      "closedAt": "2024-02-21T07:18:06Z",
      "mergedAt": "2024-02-21T07:18:06Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "325930b3bdd2f549ed10f9c1faf1bc9d5e0441bd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOInbtzM5wkriL",
          "commit": {
            "abbreviatedOid": "13fcddd"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T15:15:45Z",
          "updatedAt": "2024-02-19T16:01:13Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "not needed",
              "createdAt": "2024-02-19T15:15:45Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 13,
              "body": "is supposed to be {{I-D.ietf-lamps-rfc6712bis}}",
              "createdAt": "2024-02-19T15:19:03Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 24,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:19:49Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 33,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:19:59Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 44,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:20:13Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 62,
              "body": "check if there is no difference",
              "createdAt": "2024-02-19T15:25:28Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 71,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:27:47Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 80,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:27:53Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 89,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:30:07Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 100,
              "body": "to be done by the RFC Editors",
              "createdAt": "2024-02-19T15:30:14Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 109,
              "body": "boot-strapping",
              "createdAt": "2024-02-19T15:30:42Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 113,
              "body": "boot-strapping",
              "createdAt": "2024-02-19T15:30:48Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 124,
              "body": "Please also change | to \\|",
              "createdAt": "2024-02-19T15:34:18Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 148,
              "body": "please ensure that there is no content change",
              "createdAt": "2024-02-19T15:38:02Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 177,
              "body": "Leave this to the RFC Editors",
              "createdAt": "2024-02-19T15:49:35Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 186,
              "body": "This was correct, keep it",
              "createdAt": "2024-02-19T15:54:23Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 195,
              "body": "keep it",
              "createdAt": "2024-02-19T15:55:23Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 204,
              "body": "keep the \\[ \\] and add them to 6.1 as well",
              "createdAt": "2024-02-19T15:57:13Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            },
            {
              "originalPosition": 222,
              "body": "do not change",
              "createdAt": "2024-02-19T16:00:40Z",
              "updatedAt": "2024-02-19T16:01:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5wsxxf",
          "commit": {
            "abbreviatedOid": "13fcddd"
          },
          "author": "kiron-mx",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T15:41:50Z",
          "updatedAt": "2024-02-20T15:41:50Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "only whitespaces were deleted; reverting the change",
              "createdAt": "2024-02-20T15:41:50Z",
              "updatedAt": "2024-02-20T15:41:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5ws0ga",
          "commit": {
            "abbreviatedOid": "13fcddd"
          },
          "author": "kiron-mx",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T15:46:25Z",
          "updatedAt": "2024-02-20T15:46:25Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "only whitespaces were deleted; reverting line breaks",
              "createdAt": "2024-02-20T15:46:25Z",
              "updatedAt": "2024-02-20T15:46:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5wyZgP",
          "commit": {
            "abbreviatedOid": "727ae7e"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T07:17:52Z",
          "updatedAt": "2024-02-21T07:17:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOInbtzM5n931E",
      "title": "edit section 4.4 and move it and 5.2.5 to appendix",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/49",
      "state": "CLOSED",
      "author": "primetomas",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Fixes #45 ",
      "createdAt": "2024-02-26T21:06:37Z",
      "updatedAt": "2024-03-18T14:14:59Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "b00d8721541eff94593ccb25022fd11e0ea11698",
      "headRepository": "primetomas/cmp-updates",
      "headRefName": "section-4_2-RootCAUpdate",
      "headRefOid": "9676c758032f0e815da0413f1fd479683a8e1e36",
      "closedAt": "2024-03-18T14:14:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed in favor of PR #54",
          "createdAt": "2024-03-18T14:14:49Z",
          "updatedAt": "2024-03-18T14:14:59Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 51,
      "id": "PR_kwDOInbtzM5pGA6C",
      "title": "Addressing #50: Deprecating CAKeyUpdAnnContent and ckuann in favor of\u2026",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/51",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 RootCaKeyUpdateContent and ckuannV3 in CMP V3 as proposed by Tomas",
      "createdAt": "2024-03-08T15:26:14Z",
      "updatedAt": "2024-03-08T16:19:17Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "0686196fb1103654b285c2d9162714685d7abfc5",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "#50-RootCaKeyUpdateContent",
      "headRefOid": "5f1571d31700f544c098427840955e48263042af",
      "closedAt": "2024-03-08T16:19:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "PR_kwDOInbtzM5pGYeW",
      "title": "Addressing #50: Deprecating CAKeyUpdAnnContent and ckuann in favor of\u2026",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/52",
      "state": "MERGED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 RootCaKeyUpdateContent and ckuannV3 in CMP V3 as proposed by Tomas",
      "createdAt": "2024-03-08T16:25:06Z",
      "updatedAt": "2024-10-02T15:59:59Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "0686196fb1103654b285c2d9162714685d7abfc5",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "issue50-RootCaKeyUpdateContent",
      "headRefOid": "4c52343a522cf71556589cbcf1d6f51c87c417bb",
      "closedAt": "2024-03-18T14:07:13Z",
      "mergedAt": "2024-03-18T14:07:13Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "77d5180625f12ddddc896b4aa84bfc506a321e64"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOInbtzM5pwG93",
      "title": "Addressing #45 updating Section 4.4",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/54",
      "state": "MERGED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-15T14:12:12Z",
      "updatedAt": "2024-10-02T15:59:57Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "77d5180625f12ddddc896b4aa84bfc506a321e64",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "issue45-UpdateSection4.4",
      "headRefOid": "51debb27c93755b14440531a0e69b5a4ab484e68",
      "closedAt": "2024-03-18T14:13:33Z",
      "mergedAt": "2024-03-18T14:13:33Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "d45300e551939fbb5b02865a609c93a797866d58"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOInbtzM5znSd4",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:24:34Z",
          "updatedAt": "2024-03-15T17:24:34Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Some Language issues:\r\n\r\nOriginal:\r\nNote:  Sometime root CA certificates do not make use of any of the\r\nX.509 v3 extensions and may be X.509 v1 certificates. Therefore, root\r\nCA key update must be able to even for version 1 certificates.\r\nAnyhow, to make use of the KeyIdentifier extension for easier path\r\nbuilding, the use of X.509 v3 is recommended.\r\n\r\nSuggested:\r\nNote:  Sometimes root CA certificates do not make use of \r\nX.509 v3 extensions and may be X.509 v1 certificates. Therefore, a root\r\nCA key update must be able to work for version 1 certificates.\r\nThe use of the X.509 v3 KeyIdentifier extension is recommended for \r\neasier path building.   ",
              "createdAt": "2024-03-15T17:24:34Z",
              "updatedAt": "2024-03-15T17:24:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znc_K",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:33:39Z",
          "updatedAt": "2024-03-15T17:33:40Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "Couldn't they get the bundle of certificates (new with new, new with old, etc using the AIA v3 extension?)  if it exists in the existing certificate.  Usually it points to an http .p7c file, which could be updated by the CA when the \"new with new\" and \"new with old\" is created.",
              "createdAt": "2024-03-15T17:33:39Z",
              "updatedAt": "2024-03-15T17:33:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5zneoD",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:35:09Z",
          "updatedAt": "2024-03-15T17:35:09Z",
          "comments": [
            {
              "originalPosition": 282,
              "body": "We do this exact thing in our code when a root CA key update is done and it is detected by the client.  ",
              "createdAt": "2024-03-15T17:35:09Z",
              "updatedAt": "2024-03-15T17:35:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znl05",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:41:35Z",
          "updatedAt": "2024-03-15T17:41:36Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I like the change, thanks.",
              "createdAt": "2024-03-15T17:41:36Z",
              "updatedAt": "2024-03-15T17:41:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znnLQ",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:42:44Z",
          "updatedAt": "2024-03-15T17:42:44Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "I was not aware of this option. We could add it as a third option, if it really works.",
              "createdAt": "2024-03-15T17:42:44Z",
              "updatedAt": "2024-03-15T17:42:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znorm",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:44:06Z",
          "updatedAt": "2024-03-15T17:44:07Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "Same comment as before, the AIA extension id-ad-caIssuers could be used to get the certificates (From an LDAP, or HTTP or somewhere else).   We usually treat the two operations as separate things to be checked.  For example, we would use the AIA if it exists, and also lookup the caCertificate attribute.   If no successful path can be built to the desired target (either the old or new CA) then we fail because we didn't have access to the link certificates.",
              "createdAt": "2024-03-15T17:44:06Z",
              "updatedAt": "2024-03-15T17:44:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znudH",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:49:19Z",
          "updatedAt": "2024-03-15T17:49:20Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I updated the branch.",
              "createdAt": "2024-03-15T17:49:19Z",
              "updatedAt": "2024-03-15T17:49:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znvg-",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:50:14Z",
          "updatedAt": "2024-03-15T17:50:14Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "Is there an RFC specifying this usage of the AIA, or is it pure RFC 5280?",
              "createdAt": "2024-03-15T17:50:14Z",
              "updatedAt": "2024-03-15T17:50:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5znzD7",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T17:53:25Z",
          "updatedAt": "2024-03-15T17:53:25Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "Yes, I think it can be another option.   The purpose is to enable the client a way to lookup the certificates needed for path building (in this case the new CA cert and the CA link certificate), and RFC 5280 section 4.2.2.1 describes how id-ad-caIssuers works.   So I don't think there is a reason why it couldn't be used, its just a more standard way of looking up certificates (rather than other out-of-band mechanisms that are out of scope for this document).",
              "createdAt": "2024-03-15T17:53:25Z",
              "updatedAt": "2024-03-15T17:53:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5zn-AR",
          "commit": {
            "abbreviatedOid": "0312c79"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-15T18:02:53Z",
          "updatedAt": "2024-03-15T18:02:53Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "I don't know of any specific RFC that specifies AIA usage for CA key renewal, I think RFC 4210 was based on RFC 2510, which was around the time of RFC 3280.  I see AIA ca-Issuers was in there, but maybe it was too new at the time, or they just didn't think about using it?\r\n",
              "createdAt": "2024-03-15T18:02:53Z",
              "updatedAt": "2024-03-15T18:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5zwwvV",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T07:41:12Z",
          "updatedAt": "2024-03-18T07:41:12Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "@johngray-dev  What do you fink of this wording?\r\n\r\n~~~\r\nThe verifier does the following:\r\n1. Get the \"new with new\" and \"new with old\" certificate.\r\n    1. If an caIssuers access method is available in the authority\r\n      information access extension of the \"old with old\" certificate,\r\n      the verifier should retrieve the \"new with new\" and\r\n      \"new with new\" certificate using the specified assess location,\r\n      see Section 4.2.2.1 of {{RFC5280}}.\r\n    2. If no caIssuers access method is available, the verifier can\r\n      use the root CA update general message to request the new root\r\n      CA and link certificates from a PKI management entity, see\r\n      {{sect-5.3.19.15}}.\r\n    3. Otherwise, get it \"out-of-band\" in a trustworthy manner.\r\n2. If received the two certificates, check that the validity periods\r\n  and the subject and issuer fields match. Verify the signatures\r\n  using the old CA key (which the verifier has locally). Securely\r\n  store the new trust anchor information if all checks were\r\n  successful.\r\n3. If correct, check the signer's certificate using the new CA key.\r\n~~~\r\n",
              "createdAt": "2024-03-18T07:41:12Z",
              "updatedAt": "2024-03-18T07:41:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5zxBpo",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T08:21:44Z",
          "updatedAt": "2024-03-18T08:21:44Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "alternative proposal\r\n~~~\r\nThe verifier does the following:\r\n1. Get the \"new with new\" and \"new with old\" certificates. The location to retrieve theses certificates from, may be available in the authority information access extension of the \"old with old\" certificate, see caIssuers access method in Section 4.2.2.1 of {{RFC5280}}, or it may be locally configured.\r\n    1. If a repository is available, look up the certificates in the caCertificate attribute.\r\n    2. If a HTTP or FTP server is available, pick the certificates from the \"certs-only\" CMS message.\r\n    3. If a CMP server is available, request the certificates using the root CA update general message, see {{sect-5.3.19.15}}.\r\n    4. Otherwise, the get the certificates \"out-of-band\" using any trustworthy mechanism.\r\n2. If received the two certificates, check that the validity periods and the subject and issuer fields match. Verify the signatures using the old root CA key (which the verifier has locally). \r\n3. If all checks were successful, securely store the new trust anchor information and validate the signer's certificate.\r\n~~~",
              "createdAt": "2024-03-18T08:21:44Z",
              "updatedAt": "2024-03-18T13:05:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5zzwy1",
          "commit": {
            "abbreviatedOid": "bd601c5"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:22:01Z",
          "updatedAt": "2024-03-18T13:22:02Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "I updated the PR",
              "createdAt": "2024-03-18T13:22:01Z",
              "updatedAt": "2024-03-18T13:22:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5z0jeY",
          "commit": {
            "abbreviatedOid": "aaee886"
          },
          "author": "primetomas",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:58:13Z",
          "updatedAt": "2024-03-18T13:58:14Z",
          "comments": [
            {
              "originalPosition": 274,
              "body": "redundant \"the\", change: \"the get the\" -> \"get the\"",
              "createdAt": "2024-03-18T13:58:14Z",
              "updatedAt": "2024-03-18T13:58:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5z0kJR",
          "commit": {
            "abbreviatedOid": "aaee886"
          },
          "author": "primetomas",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T13:58:58Z",
          "updatedAt": "2024-03-18T13:58:58Z",
          "comments": [
            {
              "originalPosition": 340,
              "body": "\"the get the\" again.",
              "createdAt": "2024-03-18T13:58:58Z",
              "updatedAt": "2024-03-18T13:58:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5z0pKn",
          "commit": {
            "abbreviatedOid": "aaee886"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T14:04:24Z",
          "updatedAt": "2024-03-18T14:04:24Z",
          "comments": [
            {
              "originalPosition": 274,
              "body": "Thank you, fixed",
              "createdAt": "2024-03-18T14:04:24Z",
              "updatedAt": "2024-03-18T14:04:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM5z0pTc",
          "commit": {
            "abbreviatedOid": "aaee886"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T14:04:37Z",
          "updatedAt": "2024-03-18T14:04:38Z",
          "comments": [
            {
              "originalPosition": 340,
              "body": "Thank you, fixed",
              "createdAt": "2024-03-18T14:04:37Z",
              "updatedAt": "2024-03-18T14:04:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOInbtzM5qOOtD",
      "title": "#43 Option 1: Updated the title of Section 4.2.2",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/56",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-20T13:32:05Z",
      "updatedAt": "2024-03-20T13:37:42Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "9792ca181f8280bb14a5bc6249b809ad65f4e43d",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "Addressing-Issue34-Option1",
      "headRefOid": "cd6540574eb48ad23ad90beafc846e437bc7094d",
      "closedAt": "2024-03-20T13:37:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOInbtzM5qOQPK",
      "title": "#43 Option 2: Updated the title of Section 4.2.2 and removed normative language",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/57",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-20T13:34:47Z",
      "updatedAt": "2024-03-20T13:59:29Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "9792ca181f8280bb14a5bc6249b809ad65f4e43d",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "Addressing-Issue34-Option2",
      "headRefOid": "35b855c1c010a126d4ad196b0abab55478331f3a",
      "closedAt": "2024-03-20T13:37:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOInbtzM5qOckk",
      "title": "issue 43, option1: Update headline of Section 4.2.2",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/58",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#43 Option 1: Adapt headline of Section 4.2.2 to avoid confusion and keep text as of RFC 4210 retaining backward compatibility.",
      "createdAt": "2024-03-20T13:57:41Z",
      "updatedAt": "2024-09-05T15:43:00Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "ae8d569048acc99ba09917e66d0138bbdb18007c",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "Addressing-Issue43-Option1",
      "headRefOid": "9afc5ac459118b8a0d79d37137b36fdb42f352b7",
      "closedAt": "2024-05-06T11:19:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDOInbtzM5qOdDo",
      "title": "Updated the title of Section 4.2.2 and removed normative language",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/59",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#43 Option 2: Adapt headline of Section 4.2.2 to avoid confusion and remove normative language.",
      "createdAt": "2024-03-20T13:58:20Z",
      "updatedAt": "2024-09-05T15:43:02Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "ae8d569048acc99ba09917e66d0138bbdb18007c",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "Addressing-Issue43-Option2",
      "headRefOid": "f5eb835899e7558ac92aa26fedd714ff492efbb7",
      "closedAt": "2024-05-06T11:19:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOInbtzM5qOg7l",
      "title": "Starting rework of Sections 3, 4, and 6",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/60",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#43 Option 3: Rework Section 3, 4, and 6 to modernize it and remove normative where not needed.",
      "createdAt": "2024-03-20T14:05:02Z",
      "updatedAt": "2024-09-05T15:43:03Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "ae8d569048acc99ba09917e66d0138bbdb18007c",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "Addressing-Issue43-Option3",
      "headRefOid": "cfae209cd12753c5f677c18a3c0988e2e21a36f4",
      "closedAt": "2024-05-06T11:18:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOInbtzM5sJlgt",
      "title": "address errataum 7888",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/61",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Fixes [erratum 7888](https://www.rfc-editor.org/errata_search.php?eid=7888).",
      "createdAt": "2024-04-09T16:00:04Z",
      "updatedAt": "2024-07-04T06:55:56Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "57dd47d65c9660382fb079203e5f800177685d0d",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "seanturner-erratum-7888",
      "headRefOid": "b576dc980881005c18f621f275287e203ee95ac1",
      "closedAt": "2024-07-04T06:55:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The erratum was fixed with V10 of the draft",
          "createdAt": "2024-07-04T06:55:56Z",
          "updatedAt": "2024-07-04T06:55:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOInbtzM52mEQH",
          "commit": {
            "abbreviatedOid": "b576dc9"
          },
          "author": "seanturner",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-09T17:23:23Z",
          "updatedAt": "2024-04-09T17:23:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nAn Initialization response message contains a\r\nCertRepMessage data structure in PKIBody, which has for each certificate\r\n```",
              "createdAt": "2024-04-09T17:23:24Z",
              "updatedAt": "2024-04-09T17:23:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM52tAlC",
          "commit": {
            "abbreviatedOid": "b576dc9"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-10T12:06:54Z",
          "updatedAt": "2024-04-10T12:06:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The fixing of the erratum  (an -> a) here is fine.\r\n\r\nBut, PKIBody is a choice and I am wondering if 'as' is correct.\r\nBut I am not a native speaker, so I will follow your advice :-)\r\nIf we change the text here, we also need to change it in Sections 5.3.1, 5.3.3, and 5.3.4.",
              "createdAt": "2024-04-10T12:06:54Z",
              "updatedAt": "2024-04-10T12:06:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM53S5xE",
          "commit": {
            "abbreviatedOid": "b576dc9"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-15T15:35:54Z",
          "updatedAt": "2024-04-15T15:35:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@seanturner should I only change the a -> an or should I also implement the change you proposed to Section  5.3.1, 5.3.3, and 5.3.4?",
              "createdAt": "2024-04-15T15:35:54Z",
              "updatedAt": "2024-04-15T15:35:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOInbtzM5-DLx0",
      "title": "Editorial changes to rfc4210bis and rfc6712bis",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/64",
      "state": "MERGED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-09T09:08:11Z",
      "updatedAt": "2024-10-09T09:26:16Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "6eed3757571a7f716322e5044d6dfe16a81ab0f3",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "editorial-changes-to-rfc4210bis",
      "headRefOid": "c9956751746e507c9b3cd6b9537afa3e68aeb370",
      "closedAt": "2024-10-09T09:25:58Z",
      "mergedAt": "2024-10-09T09:25:58Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "45ce64bb6a8c5fa0cef67aa2f8821bea9bfd02c1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 66,
      "id": "PR_kwDOInbtzM6ICNH4",
      "title": "Remove root ca terminology",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/66",
      "state": "CLOSED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Implements #65 ",
      "createdAt": "2025-01-16T16:31:29Z",
      "updatedAt": "2025-01-27T11:59:31Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "8d310a4d4592005cb778e1dda7fd63819821e882",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "remove_root-CA_terminology",
      "headRefOid": "2dc38b5da189ced7d61b6214647ee5a8a143cffe",
      "closedAt": "2025-01-27T11:59:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Option 1 was rejected in favor of option 2, #67  was merged",
          "createdAt": "2025-01-27T11:59:31Z",
          "updatedAt": "2025-01-27T11:59:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOInbtzM6YZSez",
          "commit": {
            "abbreviatedOid": "d427681"
          },
          "author": "johngray-dev",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Just a few minor comments.  Generally it seems to make things clearer I think, but it does differ in language from other RFCs",
          "createdAt": "2025-01-16T17:11:54Z",
          "updatedAt": "2025-01-16T17:19:23Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Could also say \"How to bridge trust to a newly trusted CA Certificate in a CA DN change...\"",
              "createdAt": "2025-01-16T17:11:54Z",
              "updatedAt": "2025-01-16T17:19:23Z"
            },
            {
              "originalPosition": 393,
              "body": "I think I would say \"newly trusted\"",
              "createdAt": "2025-01-16T17:16:00Z",
              "updatedAt": "2025-01-16T17:19:23Z"
            },
            {
              "originalPosition": 430,
              "body": "Should this name change from RootCAKeyUpdate to TrustedCaKeyUpdate?",
              "createdAt": "2025-01-16T17:17:57Z",
              "updatedAt": "2025-01-16T17:19:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM6YZYME",
          "commit": {
            "abbreviatedOid": "d427681"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-16T17:23:01Z",
          "updatedAt": "2025-01-16T17:23:01Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "done",
              "createdAt": "2025-01-16T17:23:01Z",
              "updatedAt": "2025-01-16T17:23:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM6YZYgH",
          "commit": {
            "abbreviatedOid": "d427681"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-16T17:23:38Z",
          "updatedAt": "2025-01-16T17:23:38Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "done",
              "createdAt": "2025-01-16T17:23:38Z",
              "updatedAt": "2025-01-16T17:23:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOInbtzM6YZavP",
          "commit": {
            "abbreviatedOid": "d427681"
          },
          "author": "HBrock",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-16T17:28:02Z",
          "updatedAt": "2025-01-16T17:28:02Z",
          "comments": [
            {
              "originalPosition": 430,
              "body": "It would be great to also update the types. But this would be a breaking change for RFC 9483 because we introduced the new types already with RFC 9480 and we also registered some OIDs using the old language. Therefore, I think we should keep the syntax and address this with the note.",
              "createdAt": "2025-01-16T17:28:02Z",
              "updatedAt": "2025-01-16T17:28:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOInbtzM6IInhH",
      "title": "Option 2 - addressing DISCUSS from Paul Wouters",
      "url": "https://github.com/lamps-wg/cmp-updates/pull/67",
      "state": "MERGED",
      "author": "HBrock",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u20261.1.2, 4.4, 5.2.5, 6, and D.3.",
      "createdAt": "2025-01-17T10:19:46Z",
      "updatedAt": "2025-01-27T11:55:18Z",
      "baseRepository": "lamps-wg/cmp-updates",
      "baseRefName": "main",
      "baseRefOid": "8d310a4d4592005cb778e1dda7fd63819821e882",
      "headRepository": "lamps-wg/cmp-updates",
      "headRefName": "option2-solving-DISCUSS",
      "headRefOid": "108d268550113f94b206383ff6654c2f320785c6",
      "closedAt": "2025-01-27T11:55:18Z",
      "mergedAt": "2025-01-27T11:55:18Z",
      "mergedBy": "HBrock",
      "mergeCommit": {
        "oid": "76269f5f79615f7fff136efbee3e33dce1f43d2a"
      },
      "comments": [],
      "reviews": []
    }
  ]
}